<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Dual Core Shooter : Lethe Final Integrated</title>
    <style>
/* [ìˆ˜ì •] bodyì— touch-action: none ì¶”ê°€ (ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤ ë°©ì§€) */
        body { margin: 0; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Arial', sans-serif; overflow: hidden; touch-action: none; }
        
        /* [ìˆ˜ì •] ìº”ë²„ìŠ¤ í¬ê¸° ë°˜ì‘í˜•ìœ¼ë¡œ ë³€ê²½ */
        canvas { 
            background-color: #87ceeb; 
            border: 2px solid #555; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5); 
            max-width: 100%; 
            max-height: 100vh; 
        }
        
        /* UI ê³µí†µ */
        #ui { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; width: 100%; z-index: 10; display: none; }
        .bar-container { width: 300px; height: 15px; background-color: #444; margin: 5px auto; border: 2px solid #fff; position: relative; }
        #hp-bar { width: 100%; height: 100%; background-color: #00f0ff; transition: width 0.2s; }
        #xp-bar { width: 0%; height: 100%; background-color: #ffd700; transition: width 0.2s; }
        #boss-ui { display: none; margin-top: 10px; } 
        #boss-hp-bar { width: 100%; height: 100%; background-color: #ff00ff; transition: width 0.2s; }
        .bar-text { position: absolute; top: 0; left: 0; width: 100%; font-size: 11px; line-height: 15px; color: black; font-weight: bold; }
        .info-text { font-size: 14px; color: #333; margin-top: 5px; font-weight: bold; text-shadow: 1px 1px 0px white;}
        
        /* ì „ì²´í™”ë©´ ì˜¤ë²„ë ˆì´ */
        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
        }
        /* íƒ€ì´í‹€ í™”ë©´ */
        #title-screen { display: flex; }
        .main-title { font-size: 50px; color: #00f0ff; text-shadow: 0 0 20px #00f0ff; margin-bottom: 40px; font-weight: bold; letter-spacing: 2px; }
        .start-btn { padding: 15px 40px; font-size: 24px; background: #333; color: white; border: 3px solid #00f0ff; cursor: pointer; transition: 0.2s; font-weight: bold; }
        .start-btn:hover { background: #00f0ff; color: black; box-shadow: 0 0 20px #00f0ff; }
        .start-btn:disabled { border-color: #555; color: #555; cursor: not-allowed; box-shadow: none; background: #222; }
        /* ë¡œë“œì•„ì›ƒ í™”ë©´ */
        #loadout-screen { display: none; }
        .loadout-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 20px; 
            margin-bottom: 20px; 
            width: 100%;
        }
        /* [ì¶”ê°€] ì„ íƒëœ íŒŒì¸ ë¥¼ ë³´ì—¬ì¤„ ìƒë‹¨ ìŠ¬ë¡¯ ì˜ì—­ */
        .selection-slots {
            display: flex;
            gap: 40px;
            margin-bottom: 10px;
        }
        .slot {
            width: 120px;
            height: 140px;
            border: 3px dashed #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: #222;
            transition: 0.2s;
        }
        .slot.active {
            border-color: #00f0ff; /* í˜„ì¬ ì„ íƒ ì¤‘ì¸ ìŠ¬ë¡¯ ìƒ‰ìƒ */
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);
        }
        .slot.filled {
            border-style: solid;
            border-color: white;
            background: #333;
        }
        .slot-label { font-size: 14px; color: #aaa; margin-bottom: 10px; font-weight:bold; }
        .slot-icon { width: 40px; height: 40px; background: #333; border-radius: 50%; margin-bottom: 5px; }
        .slot-name { font-size: 16px; font-weight: bold; color: white; }

        .part-column { display: flex; flex-direction: column; align-items: center; }
        .column-title { font-size: 20px; color: #fff; margin-bottom: 10px; text-decoration: underline; }
        /* [ìˆ˜ì •] í†µí•©ëœ íŒŒì¸  ê·¸ë¦¬ë“œ */
        .part-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); /* í•œ ì¤„ì— 4ê°œì”© í‘œì‹œ */
            gap: 10px; 
            max-height: 350px;       /* ë†’ì´ ì œí•œ */
            overflow-y: auto;        /* ìŠ¤í¬ë¡¤ ìƒì„± */
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            -webkit-overflow-scrolling: touch;
        }
        .part-grid::-webkit-scrollbar { width: 8px; }
        .part-grid::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        .mini-card {
            width: 80px; height: 100px; background: #444; border: 2px solid #777;
            cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 5px; transition: 0.2s;
        }
        .mini-card:hover { border-color: white; background: #555; }
        .mini-card.selected { border-color: #ffff00; background: #666; box-shadow: 0 0 10px #ffff00; }
        .mini-card.in-use { opacity: 0.3; border-color: #333; pointer-events: none; }
        
        .mini-icon { width: 30px; height: 30px; margin-bottom: 5px; }
        .mini-name { font-size: 12px; color: white; text-align: center; }

        /* ì—…ê·¸ë ˆì´ë“œ ëª¨ë‹¬ */
        #upgrade-modal { display: none; } 
        .modal-title { font-size: 30px; margin-bottom: 20px; color: #fff; text-shadow: 0 0 10px #fff; }
        .card-container { display: flex; gap: 20px; margin-bottom: 30px; }
        .card { width: 150px; height: 260px; background: #333; border: 2px solid #fff; border-radius: 10px; cursor: pointer; display: flex; flex-direction: column; align-items: center; padding: 10px; transition: transform 0.2s, background 0.2s; position: relative; }
        .card.disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; transform: none; }
        .highlighted { border: 4px solid #ffff00 !important; box-shadow: 0 0 20px #ffff00 !important; transform: scale(1.1) !important; z-index: 10; background: #444 !important; }
        .card-icon { width: 50px; height: 50px; margin-bottom: 10px; }
        .card-name { font-size: 18px; font-weight: bold; margin-bottom: 5px; color: #ffeb3b; }
        .card-desc { font-size: 12px; color: #ccc; text-align: center; line-height: 1.4; }
        .card-level { margin-top: auto; font-size: 14px; color: #00f0ff; }
        .key-badge { position: absolute; top: 5px; left: 5px; background: #fff; color: #000; font-size: 12px; padding: 2px 6px; border-radius: 4px; font-weight: bold; }
        .max-badge { position: absolute; top: 5px; right: 5px; background: red; color: white; font-size: 12px; padding: 2px 5px; border-radius: 3px; font-weight: bold; }
        
        #fixed-upgrade-container { display: flex; gap: 20px; border-top: 1px solid #555; padding-top: 20px; }
        .fixed-btn { width: 180px; padding: 12px; background: #222; border: 2px solid #00f0ff; color: white; font-size: 16px; font-weight: bold; cursor: pointer; border-radius: 5px; transition: 0.2s; position: relative;}
        .fixed-btn:hover { background: #00f0ff; color: black; }
        
        #replace-ui { display: none; flex-direction: column; align-items: center; gap: 20px; }
        .replace-btn { width: 220px; padding: 15px; font-size: 18px; background: #555; color: white; border: 2px solid white; cursor: pointer; position: relative; }
        .replace-btn:hover { background: #777; border-color: yellow; }
        /* ì·¨ì†Œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        #btn-replace-cancel { width: 460px; background: #333; margin-top: 10px; }
        
        h1, h3 { color: #333; text-shadow: 1px 1px 2px white; }

        #mobile-controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 150px;
            pointer-events: none; z-index: 50; display: none;
        }
        /* ëª¨ë°”ì¼/íƒœë¸”ë¦¿ í™˜ê²½ì—ì„œë§Œ ì»¨íŠ¸ë¡¤ í‘œì‹œ */
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
        }

        #joystick-zone {
            position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px;
            pointer-events: auto;
        }
        #joystick-base {
            width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative; backdrop-filter: blur(2px);
        }
        #joystick-stick {
            width: 50px; height: 50px;
            background: rgba(0, 240, 255, 0.5);
            border-radius: 50%;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00f0ff; pointer-events: none;
        }
        #mobile-bomb-btn {
            position: absolute; bottom: 40px; right: 30px;
            width: 80px; height: 80px;
            background: rgba(255, 0, 0, 0.3);
            border: 2px solid red; border-radius: 50%;
            color: white; font-size: 30px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto;
            backdrop-filter: blur(2px); user-select: none;
        }
        #mobile-bomb-btn:active { background: rgba(255, 0, 0, 0.6); transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="title-screen" class="overlay-screen">
        <div class="main-title">DUAL CORE<br>STRIKER</div>
        <button class="start-btn" onclick="goToLoadout()">GAME START</button>
    </div>

    <div id="loadout-screen" class="overlay-screen">
        <h2 style="color:white; margin-bottom:20px;">BUILD YOUR SHIP</h2>
    
        <div class="selection-slots">
            <div id="slot-left" class="slot active" onclick="setSelectionTarget('left')">
                <div class="slot-label">LEFT WING</div>
                <div id="preview-left-icon" class="slot-icon"></div>
                <div id="preview-left-name" class="slot-name">SELECT</div>
            </div>
        
            <div id="slot-right" class="slot" onclick="setSelectionTarget('right')">
                <div class="slot-label">RIGHT WING</div>
                <div id="preview-right-icon" class="slot-icon"></div>
                <div id="preview-right-name" class="slot-name">WAITING...</div>
            </div>
        </div>

        <h3 id="selection-guide" style="color:#00f0ff; margin: 10px 0;">Choose Left Part</h3>

        <div class="loadout-container">
            <div class="part-grid" id="unified-part-grid"></div>
        </div>

        <button id="mission-start-btn" class="start-btn" style="font-size:20px; padding:10px 30px;" onclick="startGame()" disabled>START MISSION</button>
    </div>

    <div id="ui">
        <h1>DUAL CORE STRIKER</h1>
        <div class="bar-container">
            <div id="hp-bar"></div>
            <span class="bar-text" id="hp-text">HP: 100/100</span>
        </div>
        <div class="bar-container">
            <div id="xp-bar"></div>
            <span class="bar-text" id="xp-text">LV.1 (0/50)</span>
        </div>
        <div id="boss-ui" class="bar-container" style="border-color: #ff00ff;">
            <div id="boss-hp-bar"></div>
            <span class="bar-text" id="boss-hp-text">WARNING: BOSS</span>
        </div>
        <h3 id="scoreBoard">Score: 0</h3>
        <p class="info-text" id="bombText">ğŸ’£ BOMB: 3 (Key: Z)</p>
    </div>
    <div id="mobile-controls">
        <div id="joystick-zone">
            <div id="joystick-base">
                <div id="joystick-stick"></div>
            </div>
        </div>
        <div id="mobile-bomb-btn">ğŸ’£</div>
    </div>
    <div id="upgrade-modal" class="overlay-screen">
        <div id="select-ui" style="display:flex; flex-direction:column; align-items:center;">
            <div class="modal-title">LEVEL UP! (ì´ë™: ë°©í–¥í‚¤ / ì„ íƒ: Z)</div>
            <div class="card-container" id="card-list"></div>
            <div id="fixed-upgrade-container">
                <button class="fixed-btn" id="btn-heal" onclick="selectFixedUpgrade('heal')">â¤ï¸ HP íšŒë³µ (+20)</button>
                <button class="fixed-btn" id="btn-bomb" onclick="selectFixedUpgrade('bomb')">ğŸ’£ í­íƒ„ íšë“ (+1)</button>
            </div>
        </div>
        <div id="replace-ui">
            <div class="modal-title">êµì²´í•  ìœ„ì¹˜ ì„ íƒ (ë°©í–¥í‚¤ / Z)</div>
            <div style="font-size:14px; color:#aaa; margin-bottom:20px;">*êµì²´ ì‹œ ê¸°ì¡´ íŒŒì¸  ë ˆë²¨ ìœ ì§€</div>
            <div style="display:flex; gap:20px;">
                <button class="replace-btn" id="btn-replace-left">ì™¼ìª½ (LEFT)</button>
                <button class="replace-btn" id="btn-replace-right">ì˜¤ë¥¸ìª½ (RIGHT)</button>
            </div>
            <button class="replace-btn" id="btn-replace-cancel">ì„ íƒ ì·¨ì†Œ (CANCEL)</button>
        </div>
    </div>
    
    <canvas id="gameCanvas" width="450" height="700"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const uiHpBar = document.getElementById('hp-bar');
    const uiHpText = document.getElementById('hp-text');
    const uiXpBar = document.getElementById('xp-bar');
    const uiXpText = document.getElementById('xp-text');
    const uiBossUi = document.getElementById('boss-ui'); 
    const uiBossHpBar = document.getElementById('boss-hp-bar');
    const uiBossHpText = document.getElementById('boss-hp-text');
    const uiScore = document.getElementById('scoreBoard');
    const uiBombText = document.getElementById('bombText');
    
    const titleScreen = document.getElementById('title-screen');
    const loadoutScreen = document.getElementById('loadout-screen');
    const gameUI = document.getElementById('ui');
    const missionStartBtn = document.getElementById('mission-start-btn');
    
    const modal = document.getElementById('upgrade-modal');
    const selectUi = document.getElementById('select-ui');
    const replaceUi = document.getElementById('replace-ui');
    const cardList = document.getElementById('card-list');

    // [DATA] Updated with Lethe
    const PARTS_INFO = {
        tig: { name: "Tig", color: "dimgray", desc: "íšŒìƒ‰ ì´ì•Œ 2ë°œ ì¢Œìš° ë°œì‚¬. ì—…ê·¸ë ˆì´ë“œ: ê³µì† +25%", type: "normal" },
        leets: { name: "Leets", color: "#a020f0", desc: "ë¬´ì  5ì´ˆ ê³ ì •. ë¬´ì  ì‹œ ê³µì† ëŒ€í­ ì¦ê°€ (Lv.1 2ë°° ~ Lv.5 3ë°°)", type: "normal" },
        Ifrit: { name: "Ifrit", color: "#333", desc: "ì£¼ë³€ì„ ë„ëŠ” ê·¼ì ‘íƒ„ (ìµœëŒ€ 20ê°œ). ì—…ê¸€: ë°ë¯¸ì§€ ì¦ê°€", type: "orbit" },
        pira: { name: "Pira", color: "#ffd700", desc: "ê¸ˆìƒ‰ ì´ì•Œ. ê²½í—˜ì¹˜ íšë“ëŸ‰ ëŒ€í­ ì¦ê°€ (ìµœëŒ€ 3ë°°)", type: "normal" },
        diana: { name: "Diana", color: "#8b4513", desc: "ê°ˆìƒ‰ ì´ì•Œ. ì…íŒ ë°ë¯¸ì§€ ë§Œí¼ íšŒë³µ ", type: "normal" },
        elena: { name: "Elena", color: "cyan", desc: "ë“œë¡  ìƒì„±. ì  ì¶”ì  ê³µê²© (0.5 dmg). ì—…ê¸€: ë“œë¡  ê°œìˆ˜ +1", type: "special" },
        shasha: { name: "Shasha", color: "navy", desc: "ë‚¨ìƒ‰ ë‘¥ê·¼íƒ„ ë°©ì‚¬í˜• ë°œì‚¬(45ë„). ì—…ê¸€: íƒ„ì•Œ+1", type: "normal" },
        silphir: { name: "Silphir", color: "lightskyblue", desc: "ë¬´ì‘ìœ„ ë°œì‚¬", type: "normal" },
        lethe: { name: "Lethe", color: "gray", desc: "ë ˆì´ì €(5ì´ˆì§€ì†, 5ì´ˆì¶©ì „). ì íƒ„ ì‚­ì œ & ì§€ì†ë”œ. ì´ì†ê°ì†Œ.", type: "laser" },
        haley: { name: "Haley", color: "red", desc: "ë¹¨ê°„ìƒ‰ ì´ì•Œ ì§ì„  ë°œì‚¬. ì´ë™ì†ë„ ì¦ê°€, ë°ë¯¸ì§€ ì¼ì • í™•ë¥  íšŒí”¼", type: "buff" },
        amelia: { name: "Amelia", color: "grey", desc: "íšŒìƒ‰ ì´ì•Œ ì§ì„  ë°œì‚¬. ê³µê²©ë ¥ ë²„í”„ ", type: "buff" },
        shady: { name: "Shady", color: "grey", desc: "íšŒìƒ‰ ì´ì•Œ ì§ì„  ë°œì‚¬. íšŒí”¼ ë²„í”„ ", type: "buff" },
        rim: { name: "Rim", color: "red", desc: "ë¹¨ê°„ ì§ì‚¬íƒ„ 3ë°œ. ì—…ê¸€: íƒ„ìˆ˜+1. ë¬´ì  ì‹œ íƒ„ìˆ˜ 2ë°°", type: "normal" },
        asana: { name: "Asana", color: "green", desc: "ì´ˆë¡ ì›í˜•íƒ„. ìµœëŒ€ ì²´ë ¥ ì¦ê°€ (ê¸°ë³¸ +10%, 1ì—…ë‹¹ +10%)", type: "buff" },
        Belita: { name: "Belita", color: "#ff0000", desc: "ì²´ë ¥ ë¹„ë¡€ ë°ë¯¸ì§€/í¬ê¸°. HPê°€ ë†’ì„ìˆ˜ë¡ ê°•ë ¥í•´ì§.", type: "normal" },
        kidian: { name: "Kidian", color: "#333", desc: "ê²€ì€ íƒ„ 3ë°œ. ì¢Œìš°ëŠ” Sì ë¹„í–‰. í”Œë ˆì´ì–´ ë ˆë²¨ ë¹„ë¡€ ë°ë¯¸ì§€ ì¦ê°€ (+0.05/Lv).", type: "normal" },
        naia: { name: "Naia", color: "royalblue", desc: "íŒŒë€ ì§ì‚¬íƒ„. íŒ¨ì‹œë¸Œ: ëª¨ë“  ì•„êµ° íƒ„í™˜ì— ìœ ë„ ì„±ëŠ¥ ë¶€ì—¬ (ë ˆë²¨ ë¹„ë¡€)", type: "normal" },
        barie: { name: "Barie", color: "purple", desc: "ìì£¼ìƒ‰ ì›í˜•íƒ„. ì˜† íŒŒì¸ ì˜ ê³µê²©ì„ ë³µì œí•¨", type: "special" },
        gabia: { name: "Gabia", color: "#8B4513", desc: "ê°ˆìƒ‰ ì›í˜•íƒ„(Dmg 1). ë³´í˜¸ë§‰ ìƒì„±(Lvë‹¹ +10). ë³´í˜¸ë§‰ íŒŒê´´ ì‹œì—ë§Œ ë¬´ì .", type: "defense" },
        suro: { name: "Suro", color: "#800000", desc: "í”¼ê²© íšŸìˆ˜ë‹¹ ê³µê²©ë ¥ +1% (ìµœëŒ€ +100%). Dianaì™€ í•¨ê»˜ë¼ë©´...?", type: "normal" },
        erpin: { name: "Erpin", color: "#FFD700", desc: "ë¬´ì‘ìœ„ ì‚°íƒ„ ë°œì‚¬. 10% í™•ë¥ ë¡œ ê³µê²© ëŒ€ì‹  HP íšŒë³µ(Nerê°€ ìˆìœ¼ë©´ 20%ë¡œ ë§ˆë¦¬ì™€ ë†€ëŸ¬ê°‘ë‹ˆë‹¤).", type: "special" },
        ner: { name: "Ner", color: "#FF8C00", desc: "íƒ„ë§‰ êµ¬ì²´ íˆ¬ì²™. Lvì— ë”°ë¼ êµ¬ì²´ê°€ 12~24ë°œ ë‚œì‚¬. 20% í™•ë¥ ë¡œ ë°°ì‹ (ì êµ° êµ¬ì²´ ìƒì„±), Erpinê³¼ í•¨ê»˜ë©´ ë°°ì‹  ì•ˆ í•¨.", type: "special" }
    };

    let gameState = "title"; 
    let score = 0;
    let frame = 0;
    let nextSpawnFrame = 0;
    let flashTimer = 0; 
    let bossCooldown = 0; 
    let bossMaxHp = 100;
    
    let selectedLoadoutLeft = null;
    let selectedLoadoutRight = null;
    
    const player = {
        x: canvas.width / 2 - 25, y: canvas.height - 80, width: 50, height: 40, 
        speed: 7.5, hp: 100, maxHp: 100, bombs: 3, level: 1, currentExp: 0, maxExp: 50, 
        invincible: false, invincibleTimer: 0,
        leftPart: { id: null, level: 1 }, rightPart: { id: null, level: 1 },
        leftCooldown: 0, rightCooldown: 0, 
        // Part Specific States
        IfritOrbs: [], IfritRotation: 0, elenaDrones: [],
        leftLaser: { active: false, timer: 0 }, rightLaser: { active: false, timer: 0 }
    };
    const joystick = {
        active: false,
        x: 0, y: 0, // -1 ~ 1 ì‚¬ì´ ê°’
        originX: 0, originY: 0
    };

    let boss = null; 
    let bullets = [];
    let enemyBullets = [];
    let enemies = [];
    let expOrbs = [];
    let particles = [];
    
    let upgradeSelectedIndex = 0;
    let replaceSelection = 'left'; // 'left', 'right', 'cancel'
    let currentUpgradeChoices = [];
    let selectedNewPartId = null;

    const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, KeyZ: false };
    
    function initGame() {
        document.addEventListener('keydown', e => { 
            if(keys.hasOwnProperty(e.code)) keys[e.code]=true; 
            if (gameState === "playing") { if (e.code === 'KeyZ' && !e.repeat) useBomb(); }
            if (gameState === "paused") { handleUpgradeKey(e.code); }
        });
        document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) keys[e.code]=false; });
        // [ì¶”ê°€] ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± ë¡œì§
        const joystickZone = document.getElementById('joystick-zone');
        const stick = document.getElementById('joystick-stick');
        const bombBtn = document.getElementById('mobile-bomb-btn');
        const maxDist = 35; // ìŠ¤í‹± ì´ë™ ë°˜ê²½

        // ì¡°ì´ìŠ¤í‹± í„°ì¹˜ ì‹œì‘
        joystickZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = joystickZone.getBoundingClientRect();
            joystick.originX = rect.left + rect.width / 2;
            joystick.originY = rect.top + rect.height / 2;
            joystick.active = true;
            updateJoystick(touch.clientX, touch.clientY, stick, maxDist);
        }, {passive: false});

        // ì¡°ì´ìŠ¤í‹± ë“œë˜ê·¸
        joystickZone.addEventListener('touchmove', (e) => {
            if (!joystick.active) return;
            e.preventDefault();
            const touch = e.changedTouches[0];
            updateJoystick(touch.clientX, touch.clientY, stick, maxDist);
        }, {passive: false});

        // ì¡°ì´ìŠ¤í‹± í„°ì¹˜ ë
        const endJoystick = (e) => {
            e.preventDefault();
            joystick.active = false;
            joystick.x = 0; joystick.y = 0;
            stick.style.transform = `translate(-50%, -50%)`;
        };
        joystickZone.addEventListener('touchend', endJoystick);
        joystickZone.addEventListener('touchcancel', endJoystick);

        // í­íƒ„ ë²„íŠ¼ í„°ì¹˜
        bombBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            useBomb();
        });
        
        // ì—…ê·¸ë ˆì´ë“œ í™”ë©´ í„°ì¹˜ ì§€ì› (ëª¨ë°”ì¼ í¸ì˜ì„±)
        const selectUiDiv = document.getElementById('select-ui');
        selectUiDiv.addEventListener('touchstart', (e) => {
             // ê°„ë‹¨í•˜ê²Œ í„°ì¹˜ ì‹œ ì²«ë²ˆì§¸ í•­ëª© ì„ íƒ ì‹œë®¬ë ˆì´ì…˜ (í˜¹ì€ íƒ­í•œ ê³³ ì¢Œí‘œ ê³„ì‚° í•„ìš”í•˜ì§€ë§Œ ìƒëµ)
             // ëª¨ë°”ì¼ì—ì„œëŠ” í™”ë©´ì˜ ë²„íŠ¼ì„ ì§ì ‘ ëˆ„ë¥´ê²Œ ë˜ë¯€ë¡œ ê¸°ì¡´ onclick ì´ë²¤íŠ¸ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
        });
    }

    // [ì¶”ê°€] ì¡°ì´ìŠ¤í‹± ê³„ì‚° í•¨ìˆ˜
    function updateJoystick(clientX, clientY, stickElement, maxDist) {
        let dx = clientX - joystick.originX;
        let dy = clientY - joystick.originY;
        let distance = Math.hypot(dx, dy);

        if (distance > maxDist) {
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * maxDist;
            dy = Math.sin(angle) * maxDist;
        }

        stickElement.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        joystick.x = dx / maxDist;
        joystick.y = dy / maxDist;
    }

    // í˜„ì¬ ì–´ëŠ ìª½ì„ ì„ íƒ ì¤‘ì¸ì§€ ì¶”ì í•˜ëŠ” ë³€ìˆ˜ ('left' ë˜ëŠ” 'right')
    let currentSelectionTarget = 'left';

    function goToLoadout() {
        gameState = "loadout";
        titleScreen.style.display = "none";
        loadoutScreen.style.display = "flex";
        
        // ì´ˆê¸°í™”
        selectedLoadoutLeft = null;
        selectedLoadoutRight = null;
        setSelectionTarget('left'); // ì²˜ìŒì—” ì™¼ìª½ë¶€í„° ì„ íƒ
        renderLoadoutUI();
    }

    // ì„ íƒí•  ëŒ€ìƒ(ì™¼ìª½/ì˜¤ë¥¸ìª½)ì„ ë³€ê²½í•˜ëŠ” í•¨ìˆ˜
    function setSelectionTarget(side) {
        currentSelectionTarget = side;
        
        // ìŠ¬ë¡¯ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸ (í…Œë‘ë¦¬ í•˜ì´ë¼ì´íŠ¸)
        document.getElementById('slot-left').classList.remove('active');
        document.getElementById('slot-right').classList.remove('active');
        document.getElementById(`slot-${side}`).classList.add('active');

        // ì•ˆë‚´ ë¬¸êµ¬ ì—…ë°ì´íŠ¸
        const guide = document.getElementById('selection-guide');
        guide.innerText = side === 'left' ? "â—€ Choose LEFT Part" : "Choose RIGHT Part â–¶";
        guide.style.color = side === 'left' ? "#00f0ff" : "#ff00ff";
        renderLoadoutUI();
    }

    function renderLoadoutUI() {
        const grid = document.getElementById('unified-part-grid');
        grid.innerHTML = '';

        // í†µí•©ëœ ê·¸ë¦¬ë“œ ìƒì„±
        Object.keys(PARTS_INFO).forEach(key => {
            let info = PARTS_INFO[key];
            let div = document.createElement('div');
            div.className = 'mini-card';
            // [í•µì‹¬ ë¡œì§ ì¶”ê°€] ì¤‘ë³µ ì„ íƒ ë°©ì§€
            // í˜„ì¬ ì™¼ìª½ì„ ê³ ë¥´ëŠ” ì¤‘ì¸ë°, ì´ íŒŒì¸ ê°€ ì´ë¯¸ ì˜¤ë¥¸ìª½ì— ìˆë‹¤ë©´? -> ë¹„í™œì„±í™”
            if (currentSelectionTarget === 'left' && selectedLoadoutRight === key) {
                div.classList.add('in-use');
            }
            // í˜„ì¬ ì˜¤ë¥¸ìª½ì„ ê³ ë¥´ëŠ” ì¤‘ì¸ë°, ì´ íŒŒì¸ ê°€ ì´ë¯¸ ì™¼ìª½ì— ìˆë‹¤ë©´? -> ë¹„í™œì„±í™”
            else if (currentSelectionTarget === 'right' && selectedLoadoutLeft === key) {
                div.classList.add('in-use');
            }

            // í˜„ì¬ ì„ íƒëœ íŒŒì¸  í‘œì‹œ (ì‹œê°ì  íš¨ê³¼)
            if (currentSelectionTarget === 'left' && selectedLoadoutLeft === key) {
                div.classList.add('selected');
            }
            if (currentSelectionTarget === 'right' && selectedLoadoutRight === key) {
                div.classList.add('selected');
            }

            div.onclick = () => selectPart(key); // í´ë¦­ ì‹œ ì„ íƒ í•¨ìˆ˜ í˜¸ì¶œ
            div.innerHTML = `
                <div class="mini-icon" style="background:${info.color}; border-radius:50%;"></div>
                <div class="mini-name">${info.name}</div>
            `;
            grid.appendChild(div);
        });

        updateSlotVisuals(); // ìƒë‹¨ ìŠ¬ë¡¯ UI ê°±ì‹ 
        checkStartButton();  // ì‹œì‘ ë²„íŠ¼ í™œì„±í™” ì—¬ë¶€ ì²´í¬
    }

    // íŒŒì¸ ë¥¼ í´ë¦­í–ˆì„ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    function selectPart(key) {
        if (currentSelectionTarget === 'left') {
            selectedLoadoutLeft = key;
            // ì™¼ìª½ ì„ íƒ í›„ ìë™ìœ¼ë¡œ ì˜¤ë¥¸ìª½ ì„ íƒìœ¼ë¡œ ë„˜ì–´ê°
            if (selectedLoadoutRight === null) {
                setSelectionTarget('right');
            }
        } else {
            selectedLoadoutRight = key;
            // ì˜¤ë¥¸ìª½ ì„ íƒ í›„ì—ëŠ” ì‹œì‘ ë²„íŠ¼ ìª½ìœ¼ë¡œ ì‹œì„  ìœ ë„ (ë³„ë„ ì•¡ì…˜ ì—†ìŒ)
        }
        updateSlotVisuals();
        checkStartButton();
        renderLoadoutUI();
    }

    // ìƒë‹¨ ìŠ¬ë¡¯(ë„¤ëª¨ ë°•ìŠ¤)ì˜ ì•„ì´ì½˜ê³¼ ì´ë¦„ì„ ê°±ì‹ 
    function updateSlotVisuals() {
        updateSingleSlot('left', selectedLoadoutLeft);
        updateSingleSlot('right', selectedLoadoutRight);
    }

    function updateSingleSlot(side, key) {
        const slot = document.getElementById(`slot-${side}`);
        const iconDiv = document.getElementById(`preview-${side}-icon`);
        const nameDiv = document.getElementById(`preview-${side}-name`);

        if (key) {
            let info = PARTS_INFO[key];
            slot.classList.add('filled');
            iconDiv.style.background = info.color;
            nameDiv.innerText = info.name;
            nameDiv.style.color = info.color;
        } else {
            slot.classList.remove('filled');
            iconDiv.style.background = '#333';
            nameDiv.innerText = (side === 'left' && currentSelectionTarget === 'left') ? "SELECT" : "WAITING...";
            nameDiv.style.color = '#aaa';
        }
    }

    function checkStartButton() {
        if (selectedLoadoutLeft && selectedLoadoutRight) {
            missionStartBtn.disabled = false;
            missionStartBtn.style.borderColor = "#00f0ff";
            missionStartBtn.style.color = "white";
            missionStartBtn.style.boxShadow = "0 0 20px #00f0ff";
            document.getElementById('selection-guide').innerText = "READY TO LAUNCH!";
            document.getElementById('selection-guide').style.color = "#fff";
        } else {
            missionStartBtn.disabled = true;
            missionStartBtn.style.borderColor = "#555";
            missionStartBtn.style.color = "#555";
            missionStartBtn.style.boxShadow = "none";
        }
    }
    function startGame() {
        gameState = "playing";
        loadoutScreen.style.display = "none";
        gameUI.style.display = "block";

        //ì—…ê·¸ë ˆì´ë“œ ë ˆë²¨
        player.leftPart = { id: selectedLoadoutLeft, level: 5 };
        player.rightPart = { id: selectedLoadoutRight, level: 5 };
        
        // Reset States
        score = 0; frame = 0; player.hp = 100; player.bombs = 3; player.level = 1; player.currentExp = 0; player.maxExp = 50;
        player.elenaDrones = []; player.IfritOrbs = []; player.barieDrones = []; // [ì¶”ê°€] Barie ë“œë¡  ë°°ì—´ ì´ˆê¸°í™”
        player.naiaDrones = []; player.barieNaiaDrones = []; player.naiaRotation = 0;
        player.naiaTimer = 0;  player.naiaCurrentCount = 2; player.silphirTimer = 0; player.nerOrbs = [];

        // [ìˆ˜ì •] ë ˆì´ì € ìƒíƒœì— angle ì†ì„± ì¶”ê°€ (-Math.PI / 2ëŠ” 12ì‹œ ë°©í–¥)
        player.leftLaser = {active: false, timer: 0, angle: -Math.PI / 2}; 
        player.rightLaser = {active: false, timer: 0, angle: -Math.PI / 2};

        // [ì¶”ê°€ë¨] Gabia ë³´í˜¸ë§‰ ê´€ë ¨ ìƒíƒœ ì´ˆê¸°í™”
        player.gabiaShield = 0;
        player.gabiaMaxShield = 0;
        player.gabiaState = 'active'; // 'active' (ì‘ë™ì¤‘), 'broken' (ê¹¨ì§/ë³µêµ¬ì¤‘)
        player.gabiaHitTimer = 0; // í”¼ê²© í›„ íšŒë³µ ëŒ€ê¸° íƒ€ì´ë¨¸ (3ì´ˆ)

        // ë°˜ë°•ì ë”œë ˆì´ ì ìš© 6í”„ë ˆì„
        player.leftCooldown = 0;
        player.rightCooldown =6;

        player.totalHitCount = 0; // ì´ í”¼ê²© íšŸìˆ˜
        player.suroTimer = 0;     // Diana ì‹œë„ˆì§€ìš© íƒ€ì´ë¨¸

        enemies = []; bullets = []; enemyBullets = []; expOrbs = []; particles = []; boss = null;
        bossCooldown = 0; bossMaxHp = 100;
        updatePlayerStats();
        // [ìˆ˜ì •ë¨] ì‹œì‘ ì‹œ Gabia ë³´í˜¸ë§‰ì´ ìˆë‹¤ë©´ ì¦‰ì‹œ 100% ì¶©ì „
        if (player.gabiaMaxShield > 0) {
            player.gabiaShield = player.gabiaMaxShield;
        }
        updateUI();
        animate();
    }

    // [ì…ë ¥ ì²˜ë¦¬ ìˆ˜ì •]
    function handleUpgradeKey(code) {
        if (selectUi.style.display !== 'none') {
            // ì—…ê·¸ë ˆì´ë“œ ì„ íƒ í™”ë©´
            if (code === 'ArrowRight') {
                if(upgradeSelectedIndex < 2) upgradeSelectedIndex++;
                else if(upgradeSelectedIndex === 3) upgradeSelectedIndex = 4;
            }
            if (code === 'ArrowLeft') {
                if(upgradeSelectedIndex > 0 && upgradeSelectedIndex <= 2) upgradeSelectedIndex--;
                else if(upgradeSelectedIndex === 4) upgradeSelectedIndex = 3;
            }
            if (code === 'ArrowDown') {
                if(upgradeSelectedIndex <= 1) upgradeSelectedIndex = 3;
                else if(upgradeSelectedIndex === 2) upgradeSelectedIndex = 4;
            }
            if (code === 'ArrowUp') {
                if(upgradeSelectedIndex === 3) upgradeSelectedIndex = 1;
                else if(upgradeSelectedIndex === 4) upgradeSelectedIndex = 2;
            }
            if (code === 'KeyZ') confirmSelection();
            updateUpgradeVisuals();
        } else {
            // êµì²´ í™”ë©´ (Replace UI)
            if (code === 'ArrowLeft') {
                if(replaceSelection === 'right') replaceSelection = 'left';
            }
            if (code === 'ArrowRight') {
                if(replaceSelection === 'left') replaceSelection = 'right';
            }
            if (code === 'ArrowDown') {
                if(replaceSelection === 'left' || replaceSelection === 'right') replaceSelection = 'cancel';
            }
            if (code === 'ArrowUp') {
                if(replaceSelection === 'cancel') replaceSelection = 'left';
            }

            if (code === 'KeyZ') {
                if (replaceSelection === 'cancel') cancelReplace();
                else replacePart(replaceSelection);
            }
            // ESC backup
            if (code === 'Escape') cancelReplace();
            
            updateReplaceVisuals();
        }
    }

    function updateUpgradeVisuals() {
        const cards = document.querySelectorAll('.card');
        const btnHeal = document.getElementById('btn-heal');
        const btnBomb = document.getElementById('btn-bomb');
        cards.forEach(c => c.classList.remove('highlighted'));
        btnHeal.classList.remove('highlighted');
        btnBomb.classList.remove('highlighted');
        if (upgradeSelectedIndex <= 2) { if(cards[upgradeSelectedIndex]) cards[upgradeSelectedIndex].classList.add('highlighted'); } 
        else if (upgradeSelectedIndex === 3) { btnHeal.classList.add('highlighted'); } 
        else if (upgradeSelectedIndex === 4) { btnBomb.classList.add('highlighted'); }
    }

    function updateReplaceVisuals() {
        const btnLeft = document.getElementById('btn-replace-left');
        const btnRight = document.getElementById('btn-replace-right');
        const btnCancel = document.getElementById('btn-replace-cancel');

        btnLeft.classList.remove('highlighted');
        btnRight.classList.remove('highlighted');
        btnCancel.classList.remove('highlighted');

        if(replaceSelection === 'left') btnLeft.classList.add('highlighted');
        else if(replaceSelection === 'right') btnRight.classList.add('highlighted');
        else if(replaceSelection === 'cancel') btnCancel.classList.add('highlighted');
    }

    function confirmSelection() {
        if (upgradeSelectedIndex <= 2) {
            let partId = currentUpgradeChoices[upgradeSelectedIndex];
            let isOwned = (player.leftPart.id === partId || player.rightPart.id === partId);
            let currentLevel = 0;
            if(player.leftPart.id === partId) currentLevel = player.leftPart.level;
            else if(player.rightPart.id === partId) currentLevel = player.rightPart.level;
            if (!(isOwned && currentLevel >= 5)) { selectUpgradePart(partId); }
        } else if (upgradeSelectedIndex === 3) { selectFixedUpgrade('heal'); } 
        else if (upgradeSelectedIndex === 4) { selectFixedUpgrade('bomb'); }
    }

    function animate() {
        if (gameState !== "playing") return;
        if (frame % 60 === 0) {
            let totalRegen = 0;
        // ì™¼ìª½ íŒŒì¸ ê°€ asanaì¼ ë•Œ ë ˆë²¨ë§Œí¼ íšŒë³µëŸ‰ ì¶”ê°€
            if (player.leftPart.id === 'asana' && !player.invincible ) {
                totalRegen += ((player.leftPart.level) *0.1 ); 
            }
            // ì˜¤ë¥¸ìª½ íŒŒì¸ ê°€ asanaì¼ ë•Œ ë ˆë²¨ë§Œí¼ íšŒë³µëŸ‰ ì¶”ê°€
            if (player.rightPart.id === 'asana' && !player.invincible ) {
                totalRegen += ((player.rightPart.level) *0.1 );
            }
            if (totalRegen > 0) {
                player.hp = Math.min(player.maxHp, player.hp + totalRegen);
                updateUI(); // HP ë°” ê°±ì‹ 
                // ì‹œê° íš¨ê³¼: íšŒë³µë  ë•Œ ê¸°ì²´ ìœ„ì¹˜ì— ì´ˆë¡ìƒ‰ íŒŒí‹°í´ ìƒì„±
                createParticles(player.x + 25, player.y + 20, '#44ff44');
            }
        }
    // animate í•¨ìˆ˜ ë‚´ë¶€, try ë¸”ë¡ ì‹œì‘ ì „í›„
    // --- [Silphir íƒ€ì´ë¨¸ ë¡œì§] ---
    let hasSilphir = (player.leftPart.id === 'silphir' || player.rightPart.id === 'silphir' ||
                      (player.leftPart.id === 'barie' && player.rightPart.id === 'silphir') ||
                      (player.rightPart.id === 'barie' && player.leftPart.id === 'silphir'));
    
    // (ì¼ì‹œì •ì§€/ì—…ê·¸ë ˆì´ë“œ í™”ë©´ì—ì„œëŠ” íƒ€ì´ë¨¸ê°€ ë©ˆì¶˜ ìƒíƒœë¡œ ìœ ì§€ë¨)
    if (gameState === "playing") {
        if (hasSilphir) {
            player.silphirTimer++;
        } else {
            player.silphirTimer = 0; // í”Œë ˆì´ ì¤‘ì¸ë° Silphirê°€ ì—†ìœ¼ë©´(êµì²´ë¨) 0ìœ¼ë¡œ ì´ˆê¸°í™”
        }
    }

        // --- [Suro & Diana ì‹œë„ˆì§€ ë¡œì§] ---
        let hasSuro = (player.leftPart.id === 'suro' || player.rightPart.id === 'suro');
        let hasDiana = (player.leftPart.id === 'diana' || player.rightPart.id === 'diana');

        if (hasSuro && hasDiana && gameState === "playing") {
            player.suroTimer++;
            // 10ì´ˆ = 600í”„ë ˆì„ (60fps ê¸°ì¤€)
            if (player.suroTimer >= 600) {
                player.suroTimer = 0;
                // ìí•´ ë°ë¯¸ì§€ 1 ì ìš©
                if (player.hp > 0) {
                    player.hp -= 1;
                    player.totalHitCount++; // ìí•´ ë°ë¯¸ì§€ë„ í”¼ê²© íšŸìˆ˜ì— í¬í•¨
                    // ì‹œê° íš¨ê³¼ (í”¼ê²© ëŠë‚Œì€ ì£¼ë˜ ë¬´ì ì‹œê°„ì€ ì£¼ì§€ ì•ŠìŒ)
                    createParticles(player.x + 25, player.y + 20, '#800000');
                    updateUI();
                    // (ì„ íƒ ì‚¬í•­) ìí•´ë¡œ ì£½ì„ ìˆ˜ë„ ìˆë‹¤ë©´:
                    if (player.hp <= 0) {
                        drawGameOver();
                        return; 
                    }
                }
            }
        }

        try {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (flashTimer > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashTimer / 20})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                flashTimer--;
            }
            if (player.hp > 0) {
                updatePlayerMove();
                updatePlayerAction(); 
                updateElenaDrones(); 
                drawPlayer();
                drawElenaDrones();    
            } else {
                drawGameOver();
                return;
            }
            updateNerOrbs();
            updateBullets();
            updateEnemies();
            updateBoss();
            updateExpOrbs();
            updateParticles();
            checkCollisions(); 
            updateGabiaShield(); // [ì¶”ê°€ë¨] ë§¤ í”„ë ˆì„ ë³´í˜¸ë§‰ ë¡œì§ ìˆ˜í–‰
            frame++;
        } catch (err) { console.error(err); }
        updateElenaDrones();
        updateNaiaDrones(); // [ì¶”ê°€] Naia ë“œë¡  ì—…ë°ì´íŠ¸

        drawPlayer();
        drawElenaDrones();
        drawNaiaDrones();   // [ì¶”ê°€] Naia ë“œë¡  ê·¸ë¦¬ê¸°
        requestAnimationFrame(animate);
    }

    function updatePlayerAction() {
        processPartAction(player.leftPart, 'left'); 
        processPartAction(player.rightPart, 'right');
        
        // --- [ìˆ˜ì • ì‹œì‘] Ifrit & amelia ìƒí˜¸ì‘ìš© ë¡œì§ ---
        player.IfritRotation += 0.075; 
        const count = player.IfritOrbs.length;

        if (count > 0) {
            // 1. amelia ë ˆë²¨ ê³„ì‚° (ê°ì§€ ë²”ìœ„ ì„¤ì •ì„ ìœ„í•´)
            let ameliaLevel = 0;
            if (player.leftPart.id === 'amelia ') ameliaLevel += player.leftPart.level;
            if (player.rightPart.id === 'amelia ') ameliaLevel += player.rightPart.level;

            // 2. ê°ì§€ ê±°ë¦¬ ì„¤ì •: ê¸°ë³¸ 100 + ë ˆë²¨ë‹¹ 30ì”© ì¦ê°€
            const detectionRange = 200 + (ameliaLevel * 50);

            // ìœ ë„ ëŒ€ìƒ ëª©ë¡ (ì¼ë°˜ ì  + ë³´ìŠ¤)
            let targets = [...enemies];
            if (boss) targets.push(boss);

            // ì—­ìˆœìœ¼ë¡œ ìˆœíšŒ (ë°°ì—´ì—ì„œ ì œê±°ë  ê°€ëŠ¥ì„±ì„ ëŒ€ë¹„í•´ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬)
            for (let i = player.IfritOrbs.length - 1; i >= 0; i--) {
                let orb = player.IfritOrbs[i];

                // A. ì´ë¯¸ ìœ ë„ ëª¨ë“œ(homing)ì¸ ê²½ìš°: ë…ìì ìœ¼ë¡œ ë¹„í–‰
                if (orb.homing) {
                    orb.x += orb.vx;
                    orb.y += orb.vy;

                    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì‚­ì œ (ë©”ëª¨ë¦¬ ê´€ë¦¬)
                    if (orb.x < -50 || orb.x > canvas.width + 50 || orb.y < -50 || orb.y > canvas.height + 50) {
                        player.IfritOrbs.splice(i, 1);
                    }
                    continue; // ë‹¤ìŒ ì˜¤ë¸Œë¡œ ë„˜ì–´ê°
                }

                // B. ëŒ€ê¸° ëª¨ë“œ(íšŒì „ ì¤‘): í”Œë ˆì´ì–´ ì£¼ë³€ ìœ„ì¹˜ ê³„ì‚°
                let angleOffset = (Math.PI * 2 / count) * i;
                let currentAngle = player.IfritRotation + angleOffset;

                let orbitRadius = (orb.source === 'barie') ? 80 : 60;
                
                // ì›ë˜ ìˆì–´ì•¼ í•  íšŒì „ ìœ„ì¹˜
                let orbitX = (player.x + player.width/2) + Math.cos(currentAngle) * orbitRadius;
                let orbitY = (player.y + player.height/2) + Math.sin(currentAngle) * orbitRadius;

                // ì ì´ ì¡´ì¬í•  ê²½ìš° ê±°ë¦¬ ì²´í¬
                let launched = false;
                if (targets.length > 0) {
                    let closest = null;
                    let minDist = Infinity;

                    // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                    targets.forEach(t => {
                        let dist = Math.hypot((t.x + t.width/2) - orbitX, (t.y + t.height/2) - orbitY);
                        if (dist < minDist) { minDist = dist; closest = t; }
                    });

                    // ê°ì§€ ê±°ë¦¬ ì•ˆì— ì ì´ ë“¤ì–´ì™”ë‹¤ë©´ ë°œì‚¬
                    if (closest && minDist <= detectionRange) {
                        orb.homing = true; // ìƒíƒœ ë³€ê²½
                        
                        // ì ì„ í–¥í•œ ë°œì‚¬ ê°ë„ ë° ì†ë„ ê³„ì‚°
                        let angle = Math.atan2((closest.y + closest.height/2) - orbitY, (closest.x + closest.width/2) - orbitX);
                        let speed = 12; // ë°œì‚¬ ì†ë„
                        
                        orb.vx = Math.cos(angle) * speed;
                        orb.vy = Math.sin(angle) * speed;
                        
                        // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë°œì‚¬ ì‹œì‘
                        orb.x = orbitX;
                        orb.y = orbitY;
                        launched = true;
                    }
                }

                // ë°œì‚¬ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ê³„ì† í”Œë ˆì´ì–´ ì£¼ë³€ íšŒì „
                if (!launched) {
                    orb.x = orbitX;
                    orb.y = orbitY;
                }
            }
        }
        // --- [ìˆ˜ì • ë] ---
    }

    function processPartAction(part, side) {
        // [Barie ë¡œì§ êµ¬í˜„]
        // ì‹¤ì œë¡œ ë¡œì§ì„ ìˆ˜í–‰í•  íŒŒì¸  ì •ë³´(runPart)ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
        let runPart = part;
        // íŒŒíŠ¸ë„ˆ íŒŒì¸  ì°¾ê¸°
        let partner = (side === 'left') ? player.rightPart : player.leftPart;

        if (part.id === 'barie') {
            // [í•µì‹¬ ë³€ê²½] íŒŒíŠ¸ë„ˆê°€ Letheë¼ë©´ BarieëŠ” ê³µê²©ì„ í•˜ì§€ ì•Šê³  ì„œí¬íŠ¸ ëª¨ë“œë¡œ ì „í™˜ (Lethe ë¡œì§ì—ì„œ ì²˜ë¦¬)
            if (partner.id === 'lethe') return;
            // ê°€ìƒì˜ íŒŒì¸  ìƒì„±: IDëŠ” íŒŒíŠ¸ë„ˆ ê²ƒ, ë ˆë²¨ì€ (íŒŒíŠ¸ë„ˆ ë ˆë²¨ + Barie ë ˆë²¨) í•©ì‚°
            runPart = { id: partner.id, level: part.level };
        }
        // ElenaëŠ” active shotì´ ì—†ìœ¼ë¯€ë¡œ ë¦¬í„´ (Elena ë³¸ì²´ë“ , Barieê°€ Elenaë¥¼ ë² ê¼ˆë“ )
        if(runPart.id === 'elena') return;

        // ì•„ë˜ë¶€í„°ëŠ” 'part' ëŒ€ì‹  'runPart' ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ê³µê²© ë¡œì§ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
        let hasLeets = (player.leftPart.id === 'leets' || player.rightPart.id === 'leets');
        let haleyLevel = 0;
        if(player.leftPart.id === 'haley') haleyLevel = Math.max(haleyLevel, player.leftPart.level);
        if(player.rightPart.id === 'haley') haleyLevel = Math.max(haleyLevel, player.rightPart.level);
        
        let isBerserk = hasLeets && player.invincible;
        let isOffmask = (player.leftPart.id === 'rim' || player.rightPart.id === 'rim') && player.invincible;

        // [Lethe Logic] runPart ì‚¬ìš©
        if (runPart.id === 'lethe') {
            let laser = (side === 'left') ? player.leftLaser : player.rightLaser;
            let cdKey = side + 'Cooldown';

            let isBoosted = (partner.id === 'barie');
            
            if (typeof laser.angle === 'undefined') laser.angle = -Math.PI / 2;
            
            let ameliaLevel = 0;
            if (player.leftPart.id === 'amelia') ameliaLevel += player.leftPart.level;
            if (player.rightPart.id === 'amelia') ameliaLevel += player.rightPart.level;
            
            let ox;
            if (isBoosted) {
                ox = player.x + 25;
            } else {
                ox = (side === 'left') ? player.x + 10 : player.x + 40;
            }
            let oy = player.y;

            if (laser.active) {
                laser.timer--;
                if (!laser.acc) laser.acc = 0;

                let currentSpeedMult = 0;
                if (isOffmask) currentSpeedMult = 1;
                if (isBoosted) currentSpeedMult = 1;

                laser.acc += Math.max(1, 1+currentSpeedMult);
                
                // amelia ì˜¤í†  ì—ì„
                if (ameliaLevel > 0) {
                    let closest = null;
                    let minDist = Infinity;
                    let targets = [...enemies];
                    if (boss) targets.push(boss);

                    targets.forEach(t => {
                        let dx = (t.x + t.width/2) - (player.x + 25);
                        let dy = (t.y + t.height/2) - (player.y + 20);
                        let dist = dx*dx + dy*dy;
                        if (dist < minDist) { minDist = dist; closest = t; }
                    });

                    let targetAngle = -Math.PI / 2;
                    if (closest) {
                        let tx = closest.x + closest.width/2;
                        let ty = closest.y + closest.height/2;
                        targetAngle = Math.atan2(ty - (player.y + 20), tx - (player.x + 25));
                    }

                    let turnSpeed = 0.02 + (ameliaLevel * 0.01);
                    let diff = targetAngle - laser.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;

                    if (Math.abs(diff) < 0.01) laser.angle = targetAngle;
                    else laser.angle += diff * turnSpeed

                } else {
                    laser.angle = -Math.PI / 2;
                }

                if (laser.acc >= 6) {
                    laser.acc -= 6;
                    
                    // ë°ë¯¸ì§€ ê³„ì‚° ì‹œ runPart.level ì‚¬ìš© (í•©ì‚°ëœ ë ˆë²¨)
                    let baseW = 2 + (runPart.level - 1) * 0.5; 
                    let lw = isBoosted ? baseW * 1.5 : baseW;
                    let damageMultiplier = 1.0;
                    let damageAdd = 0;
                    if (player.leftPart.id === 'leets') damageMultiplier += 0.20 + (player.leftPart.level - 1) * 0.2;
                    if (player.rightPart.id === 'leets') damageMultiplier += 0.20 + (player.rightPart.level - 1) * 0.2;
                    if (isBerserk) damageAdd = 1 ;
                    let damage = (2 + (runPart.level - 1) * 0.5) * damageMultiplier*getSilphirMultiplier() + damageAdd; 

                    const checkLaserHit = (target, lx, ly, angle, width, range) => {
                        let tx = target.x + target.width/2;
                        let ty = target.y + target.height/2;
                        let vx = Math.cos(angle);
                        let vy = Math.sin(angle);
                        let pdx = tx - lx;
                        let pdy = ty - ly;
                        let dot = pdx * vx + pdy * vy;
                        if (dot < 0 || dot > range) return false;
                        let distSq = (pdx*pdx + pdy*pdy) - (dot*dot);
                        let targetRadius = target.width / 2;
                        let hitDist = (width/2) + targetRadius;
                        return distSq < (hitDist * hitDist);
                    };

                    let lx = player.x + 25; 
                    let ly = player.y + 20; 
                    let range = 1000;       

                    enemies.forEach((e, idx) => {
                        if (checkLaserHit(e, ox, oy, laser.angle, lw, range)) {
                            e.hp -= damage; e.hitTimer = 5;
                            createParticles(e.x + e.width/2, e.y + e.height/2, 'red');
                            applyDianaLifesteal(damage);
                            if (e.hp <= 0) { enemies.splice(idx, 1); score += 100; spawnExpOrb(e.x, e.y); }
                        }
                    });

                    if (boss && checkLaserHit(boss, lx, ly, laser.angle, lw, range)) {
                        boss.hp -= damage; boss.hitTimer = 5; createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 'red');
                        applyDianaLifesteal(damage);
                        if (boss.hp <= 0) killBoss();
                    }
                    
                    for (let i = enemyBullets.length - 1; i >= 0; i--) {
                        let eb = enemyBullets[i];
                        let ebObj = {x: eb.x - 5, y: eb.y - 5, width: 10, height: 10}; 
                        if (checkLaserHit(ebObj, lx, ly, laser.angle, lw, range)) {
                            enemyBullets.splice(i, 1);
                            createParticles(eb.x, eb.y, 'orange');
                        }
                    }
                }

                if (laser.timer <= 0) {
                    laser.active = false;
                    laser.acc = 0;
                    player[cdKey] = isOffmask ? 0 : (300 - 40*(haleyLevel));
                }
                return; 
            } else {
                if (isOffmask) player[cdKey] = 0;
                if (player[cdKey] > 0) { player[cdKey]--; return; } 
                else { laser.active = true; laser.timer = 300; return; }
            }
        }

        // ì¼ë°˜ ì¿¨ë‹¤ìš´ ë¡œì§ (Barie ìŠ¬ë¡¯ì˜ ì¿¨ë‹¤ìš´ì„ ì‚¬ìš©)
        let cdKey = side + 'Cooldown'; if (player[cdKey] > 0) player[cdKey]--;
        
        if (player[cdKey] <= 0) {
            let baseCd = 0;
            // ë°œì‚¬ ìœ„ì¹˜ëŠ” í˜„ì¬ Barieê°€ ì¥ì°©ëœ sideë¥¼ ë”°ë¦„
            let bx = side === 'left' ? player.x + 10 : player.x + player.width - 10;
            
            // ì—¬ê¸°ì„œë¶€í„° part ëŒ€ì‹  runPartë¥¼ ì‚¬ìš©
            if (runPart.id === 'tig') {
                baseCd = Math.floor(6 / (1 + (runPart.level - 1) * 0.25)); 
                let x1 = side === 'left' ? player.x + 5 : player.x + 30; let x2 = side === 'left' ? player.x + 20 : player.x + 45;
                spawnBullet(x1, player.y, 0, -22, 6, 6, 'dimgray', 0.5); spawnBullet(x2, player.y, 0, -22, 6, 6, 'dimgray', 0.5); 
            } else if (runPart.id === 'leets') {
                baseCd = 12; spawnBullet(bx, player.y, 0, -22, 8, 8, '#a020f0', 1, 'circle');
            } else if (runPart.id === 'Ifrit') {
                let currentSource = (part.id === 'barie') ? 'barie' : 'Ifrit';
                let myOrbCount = player.IfritOrbs.filter(orb => orb.source === currentSource).length;
                let maxOrbs = 5 + (runPart.level * 2);
                if (myOrbCount < maxOrbs) { 
                    let baseDmg = 5 * (1 + (runPart.level - 1) * 0.25);
                    let damageMultiplier = 1.0;
                    let damageAdd = 0;
                    if (player.leftPart.id === 'leets') damageMultiplier += 0.20 + (player.leftPart.level - 1) * 0.2;
                    if (player.rightPart.id === 'leets') damageMultiplier += 0.20 + (player.rightPart.level - 1) * 0.2;
                    if (isBerserk) damageAdd = 1 ;
                    let orbColor = '#333'; // ê¸°ë³¸ Ifrit ìƒ‰ìƒ (ê²€ì€ìƒ‰)
                    if (part.id === 'barie') {
                    orbColor = '#d000ff'; // Barie ë³µì œ êµ¬ì²´ ìƒ‰ìƒ (ë°ì€ ë³´ë¼ìƒ‰, ë“œë¡ ê³¼ ê¹”ë§ì¶¤)
                    }
                    player.IfritOrbs.push({ w:10, h:10, color: orbColor, damage: baseDmg * damageMultiplier * getSilphirMultiplier() + damageAdd, x:0, y:0, source: currentSource}); 
                    baseCd = 20; 
                } 
            } else if (runPart.id === 'pira') { spawnBullet(bx, player.y, 0, -22, 8, 8, '#ffd700', 1, 'circle'); baseCd = 12; } 
            else if (runPart.id === 'diana') { spawnBullet(bx, player.y, 0, -22, 8, 8, '#8b4513', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'asana') { spawnBullet(bx, player.y, 0, -22, 8, 8, 'green', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'shady') { spawnBullet(bx, player.y, 0, -22, 8, 8, 'grey', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'haley') { spawnBullet(bx, player.y, 0, -22, 8, 8, 'green', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'gabia') { spawnBullet(bx, player.y, 0, -20, 8, 8, '#8B4513', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'amelia') { spawnBullet(bx, player.y, 0, -20, 8, 8, 'grey', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'silphir') { spawnBullet(bx, player.y, 0, -20, 8, 8, 'blue', 1, 'circle'); baseCd = 12; }
            else if (runPart.id === 'barie') { 
                // ë³µì‚¬í–ˆëŠ”ë° ë˜ Barieì¸ ê²½ìš°(ì¼ì–´ë‚  ìˆ˜ ì—†ìŒ) ì²˜ë¦¬, ê¸°ì¡´ í­ë°œíƒ„ ìœ ì§€
                spawnBullet(bx, player.y, 0, -20, 6, 8, 'purple', 1, 'circle'); baseCd = 12; 
            }
            else if (runPart.id === 'shasha') {
                let bulletCount = 5 + (runPart.level - 1) * 1; 
                let dmg = 0.5; 
                let maxSpread = Math.PI / 4; 
                let startAngle = -Math.PI / 2 - maxSpread / 2;
                let totalArc = maxSpread;
                for (let i = 0; i < bulletCount; i++) {
                    let angle = -Math.PI / 2;
                    if (bulletCount > 1) { angle = startAngle + (totalArc * i / (bulletCount - 1)); }
                    let vx = Math.cos(angle) * 15; let vy = Math.sin(angle) * 15;
                    spawnBullet(bx, player.y, vx, vy, 6, 6, 'navy', dmg, 'circle');
                }
                baseCd = 12; 
            } else if (runPart.id === 'rim') {
                let count = 3 + (runPart.level - 1); 
                let spacing = 12; 
                let startX = bx - ((count - 1) * spacing) / 2; 
                for (let i = 0; i < count; i++) {
                    spawnBullet(startX + (i * spacing), player.y, 0, -22, 5, 10, 'red', 0.5);
                }
                baseCd = 12; 
            }
            else if (runPart.id === 'Belita') {
                let hpRatio = player.hp / 100;
                let baseDmg = Math.max(1, 3 * (hpRatio * hpRatio) * (1+(runPart.level - 1) * 0.25));   
                let bulletSize = Math.max(3,  8 * hpRatio* (1+(runPart.level - 1) * 0.25));
                spawnBullet(bx, player.y, 0, -18, bulletSize, bulletSize, 'red', baseDmg, 'circle');  
                baseCd = 12; 
            }
            else if (runPart.id === 'kidian') {
                let levelBonus = runPart.level * player.level * 0.01;
                // [ì¶”ê°€ë¨] ì‹œë„ˆì§€ ë¡œì§: íŒŒíŠ¸ë„ˆê°€ Piraë¼ë©´ Piraì˜ ë ˆë²¨ë§Œí¼ ê¸°ë³¸ ë°ë¯¸ì§€ ì¦ê°€
                let piraBonus = 1;
                if (partner.id === 'pira') {
                    piraBonus = 1 + partner.level*0.3; 
                }
                let finalBaseDmg = Math.max(0.2, levelBonus) * piraBonus ; 

                let startX = bx - 12; 
                for (let i = 0; i < 3; i++) {
                    spawnBullet(startX + (i * 12), player.y, 0, -22, 5, 10, 'black', finalBaseDmg,'circle');
                }
                for (let i = 0; i < 2; i++) {
                    let angle = -Math.PI / 2;
                    angle = -Math.PI * 5 / 8 + (Math.PI / 4 * i );
                    let vx = Math.cos(angle) * 15; let vy = Math.sin(angle) * 15;
                    spawnBullet(bx, player.y, vx, vy, 6, 6, 'black', finalBaseDmg);
                }
                baseCd = 12; 
            }

            else if (runPart.id === 'suro') {
                let hitBonus = Math.min(1.0, player.totalHitCount * 0.01);
                let baseDmg = 0.5 * (1 + (runPart.level - 1) * 0.25);
                let finalDmg = baseDmg * (1 + hitBonus);
                let speedY = -20; 
                spawnBullet(bx, player.y, 0, speedY, 6, 10, 'black', finalDmg);
                let bLeft = spawnBullet(bx - 10, player.y, -0.5, speedY, 6, 10, 'black', finalDmg);
                bLeft.trajectory = 'sine'; bLeft.timer = 10; bLeft.sidePhase = 1; 
                let bRight = spawnBullet(bx + 10, player.y, 0.5, speedY, 6, 10, 'black', finalDmg);
                bRight.trajectory = 'sine'; bRight.timer = 10; bRight.sidePhase = -1;      
                baseCd = 12; 
            }
            else if (runPart.id === 'erpin') {
                // 1. ì‹œë„ˆì§€ íŒŒì¸ (Ner) í™•ì¸
                // í˜„ì¬ íŒŒì¸ ì˜ íŒŒíŠ¸ë„ˆê°€ Nerì¸ì§€ í™•ì¸ (Barieê°€ ë³µì œí•œ ê²½ìš°ë„ partner ë³€ìˆ˜ê°€ ì²˜ë¦¬í•´ì¤Œ)
                let hasNer = (partner.id === 'ner');

                // 2. ë•¡ë•¡ì´(íšŒë³µ) í™•ë¥  ê³„ì‚°
                let lazyChance = 0.2; // ê¸°ë³¸ 20%
                if (hasNer) lazyChance = 0.4; // Nerê°€ ìˆìœ¼ë©´ 0%

                // 3. ë¡œì§ ì‹¤í–‰
                if (Math.random() < lazyChance) {
                    // [ë†ë•¡ì´ ëª¨ë“œ] ê³µê²© ì•ˆ í•¨ + HP 1 íšŒë³µ
                    if (hasNer && lazyChance < 0.2) {
                        if (hasNer && lazyChance < 0.002) {
                            player.bombs++;
                            createParticles(bx, player.y, '#00ff00'); // ì´ˆë¡ìƒ‰ íŒŒí‹°í´
                            console.log("Erpin found a marie"); 
                            updateUI();
                        }
                    } else {
                    player.hp = Math.min(player.maxHp, player.hp + 1);
                    }
        
                    // íšŒë³µ ì´í™íŠ¸ (ì´ˆë¡ìƒ‰ í…ìŠ¤íŠ¸ë‚˜ íŒŒí‹°í´)
                    createParticles(bx, player.y, '#00ff00');
                    // (ì„ íƒ) ë¡œê·¸ ì¶œë ¥
                    console.log("Erpin is slacking off...");
        
                    updateUI(); // ì²´ë ¥ ê°±ì‹ 
                } else {
                    // [ê³µê²© ëª¨ë“œ] ì™„ì „ ë¬´ì‘ìœ„ ë‚œì‚¬ (Chaos Shot)
                    let count = 8 + (runPart.level - 1) * 2;
                    
                    for (let i = 0; i < count; i++) {
                        // [ê°ë„]: 0 ~ 360ë„ (2PI) ì‚¬ì´ì˜ ì™„ì „ ë¬´ì‘ìœ„ ê°ë„
                        let angle = (Math.random()-0.5- Math.PI) / 2; 
                        
                        // ì†ë„ë„ ì•½ê°„ì˜ ì°¨ì´ë¥¼ ì£¼ì–´ ë” í˜¼ë€ìŠ¤ëŸ½ê²Œ (10 ~ 15 ì‚¬ì´)
                        let speed = 10 + Math.random() * 10;

                        let vx = Math.cos(angle) * speed;
                        let vy = Math.sin(angle) * speed;

                        spawnBullet(bx, player.y, vx, vy, 5, 5, '#FFD700', 0.4, 'circle');
                    }
                }
    
                baseCd = 20; // 20í”„ë ˆì„ë§ˆë‹¤ í–‰ë™
            }

            else if (runPart.id === 'ner') {
                // 1. ì‹œë„ˆì§€ íŒŒì¸ (Erpin) í™•ì¸
                let hasErpin = (partner.id === 'erpin');
    
                // 2. ë°°ì‹  í™•ë¥  ê³„ì‚° (ê¸°ë³¸ 20%, Erpin ìˆìœ¼ë©´ 0%)
                let traitorChance = 0.2;
                if (hasErpin) traitorChance = 0;

                // 3. ë°°ì‹  ì—¬ë¶€ ê²°ì •
                let isTraitor = (Math.random() < traitorChance);

                // 4. êµ¬ì²´ ìƒì„±í•˜ì—¬ ë°°ì—´ì— ì¶”ê°€
                player.nerOrbs.push({
                    x: bx,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 2, // ì•½ê°„ ì¢Œìš°ë¡œë„ í”ë“¤ë¦¬ë©° ë‚ ì•„ê°
                    vy: -5, // ìœ„ë¡œ ë‚ ì•„ê°€ëŠ” ì†ë„
                    width: 20, 
                    height: 20,
                    isEnemy: isTraitor, 
                    timer: 0,
                    level: runPart.level,
                    // [ìˆ˜ì •ë¨] ëœë¤ í­ë°œ ì‹œê°„ ì„¤ì • (30 ~ 90 í”„ë ˆì„ ì‚¬ì´, ì•½ 0.5ì´ˆ ~ 1.5ì´ˆ)
                    explodeTime: 60 + Math.random() * 60 
                });

                baseCd = 60; 
            }

            let speedMult = 1 + (haleyLevel) * 0.1;
            if (isOffmask && baseCd > 0) {
                speedMult *= 2
            }
            baseCd = Math.floor(baseCd / speedMult);
            if (baseCd > 0) player[cdKey] = baseCd;
        }
    }
    function updateElenaDrones() {

        // 1. ë“œë¡  ê°œìˆ˜ ëª©í‘œì¹˜ ê³„ì‚°
        let elenaTargetCount = 0;
        let barieTargetCount = 0;

        // Elena íŒŒì¸  ì²´í¬
        if (player.leftPart.id === 'elena') elenaTargetCount += player.leftPart.level;
        if (player.rightPart.id === 'elena') elenaTargetCount += player.rightPart.level;

        // Barie íŒŒì¸  ì²´í¬ (ìƒëŒ€ë°©ì´ Elenaì¼ ë•Œë§Œ)
        if (player.leftPart.id === 'barie' && player.rightPart.id === 'elena') {
            barieTargetCount += player.leftPart.level;
        }
        if (player.rightPart.id === 'barie' && player.leftPart.id === 'elena') {
            barieTargetCount += player.rightPart.level;
        }
        //rim íŒŒì¸  ì²´í¬
        let isOffmask = (player.leftPart.id === 'rim' || player.rightPart.id === 'rim') && player.invincible;

        // 2. ë°°ì—´ ê¸¸ì´ ë™ê¸°í™” (ìƒì„± ë° ì‚­ì œ)
        while (player.elenaDrones.length < elenaTargetCount) player.elenaDrones.push({ x: player.x, y: player.y, cooldown: 0 });
        while (player.elenaDrones.length > elenaTargetCount) player.elenaDrones.pop();

        while (player.barieDrones.length < barieTargetCount) player.barieDrones.push({ x: player.x, y: player.y, cooldown: 0 });
        while (player.barieDrones.length > barieTargetCount) player.barieDrones.pop();

        // 3. ê³µí†µ ë³€ìˆ˜ ê³„ì‚° (amelia ì†ë„, ê³µì† ë²„í”„ ë“±)
        let ameliaLevel = 0;
        if (player.leftPart.id === 'amelia') ameliaLevel += player.leftPart.level;
        if (player.rightPart.id === 'amelia') ameliaLevel += player.rightPart.level;
        // Barieê°€ ameliaë¥¼ ë³µì‚¬í•˜ëŠ” ê²½ìš°
        if (player.leftPart.id === 'barie' && player.rightPart.id === 'amelia') ameliaLevel += player.leftPart.level;
        if (player.rightPart.id === 'barie' && player.leftPart.id === 'amelia') ameliaLevel += player.rightPart.level;

        let haleyLevel = 0;
        if (player.leftPart.id === 'haley') haleyLevel = Math.max(haleyLevel, player.leftPart.level);
        if (player.rightPart.id === 'haley') haleyLevel = Math.max(haleyLevel, player.rightPart.level);

        // 4. ë“œë¡  ì›€ì§ì„ ì²˜ë¦¬ ë‚´ë¶€ í•¨ìˆ˜
        const processDroneGroup = (drones, bulletColor, yOffset) => {
            let targetedEnemyIds = new Set();
            const getDist = (o1, o2) => Math.hypot(o1.x - o2.x, o1.y - o2.y);
            const spacing = 25; 
            let targetGroups = {}; 
            let playerKey = 'player_pos';

            // íƒ€ê²Ÿ ì„ ì •
            drones.forEach((drone) => {
                let target = null;
                let bestDist = Infinity;
                let candidates = [...enemies];
                if (boss) candidates.push(boss);

                candidates.forEach(e => {
                    if (!targetedEnemyIds.has(e.id)) {
                        let d = getDist(drone, e);
                        if (d < bestDist) { bestDist = d; target = e; }
                    }
                });
                
                // íƒ€ê²Ÿì„ ëª» ì°¾ì•˜ìœ¼ë©´ ì´ë¯¸ íƒ€ê²ŸíŒ…ëœ ì ì´ë¼ë„ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                if (!target) {
                    bestDist = Infinity;
                    candidates.forEach(e => {
                        let d = getDist(drone, e);
                        if (d < bestDist) { bestDist = d; target = e; }
                    });
                }

                if (target) {
                    targetedEnemyIds.add(target.id);
                    if (!targetGroups[target.id]) targetGroups[target.id] = { targetObj: target, drones: [] };
                    targetGroups[target.id].drones.push(drone);
                } else {
                    if (!targetGroups[playerKey]) targetGroups[playerKey] = { targetObj: null, drones: [] };
                    targetGroups[playerKey].drones.push(drone);
                }
            });

            // ì´ë™ ë° ë°œì‚¬
            Object.values(targetGroups).forEach(group => {
                let target = group.targetObj;
                let dronesInGroup = group.drones;
                let groupSize = dronesInGroup.length;

                dronesInGroup.forEach((drone, localIndex) => {
                    let offset = (localIndex - (groupSize - 1) / 2) * spacing;
                    let destX, destY;
                    if (target) {
                        destX = target.x + target.width / 2 + offset;
                        destY = target.y + target.height + 60 + yOffset;
                    } else {
                        destX = player.x + player.width / 2 + offset;
                        destY = player.y + player.height / 2 + yOffset;
                    }

                    let dx = destX - drone.x;
                    let dy = destY - drone.y;
                    let dist = Math.hypot(dx, dy);
                    let droneSpeed = 5 + (ameliaLevel * 2);

                    if (dist > droneSpeed) {
                        drone.x += (dx / dist) * droneSpeed;
                        drone.y += (dy / dist) * droneSpeed;
                    } else {
                        drone.x = destX;
                        drone.y = destY;
                    }

                    if (target && drone.cooldown <= 0) {
                        if (Math.abs(drone.x - destX) < 20) {
                            // ì´ì•Œ ìƒ‰ìƒì„ ì¸ìë¡œ ë°›ìŒ
                            spawnBullet(drone.x, drone.y, 0, -25, 4, 10, bulletColor, 0.5); 
                            
                            let droneCd = 10;
                            let speedMult = 1
                            if (haleyLevel > 0 && !player.invincible) {
                                speedMult = 1 + haleyLevel * 0.1;
                                droneCd = Math.floor(droneCd / speedMult);
                            } else if (isOffmask) {
                                speedMult = 2;
                                droneCd = Math.floor(droneCd / speedMult);
                            }
                            drone.cooldown = droneCd; 
                        }
                    }
                    if (drone.cooldown > 0) drone.cooldown--;
                });
            });
        };

        // 5. ê°ê° ì‹¤í–‰ (ElenaëŠ” ì²­ë¡ìƒ‰íƒ„, BarieëŠ” ë³´ë¼ìƒ‰íƒ„)
        if (player.elenaDrones.length > 0) processDroneGroup(player.elenaDrones, 'cyan', 0);
        if (player.barieDrones.length > 0) processDroneGroup(player.barieDrones, 'purple', 30);
    }

    function updateNaiaDrones() {
        let radius = 60; 
        
        // --- [ë²„í”„ ê³„ì‚°] ---
        // (ê¸°ì¡´ê³¼ ë™ì¼: Haley ê³µì†, Rim ë¬´ì  ê³µì†)
        let haleyLevel = 0;
        if (player.leftPart.id === 'haley') haleyLevel = Math.max(haleyLevel, player.leftPart.level);
        if (player.rightPart.id === 'haley') haleyLevel = Math.max(haleyLevel, player.rightPart.level);
        
        let isOffmask = (player.leftPart.id === 'rim' || player.rightPart.id === 'rim') && player.invincible;

        let speedMult = 1.0;
        if (haleyLevel > 0 && !player.invincible) speedMult += haleyLevel * 0.1;
        if (isOffmask) speedMult *= 2;

        let finalCooldown = Math.floor(6 / speedMult);

        // --- 3. [ì‹ ê·œ] Naia ë° Barie ë ˆë²¨ ê³„ì‚° ---
        let naiaLevel = 0;
        if (player.leftPart.id === 'naia') naiaLevel = Math.max(naiaLevel, player.leftPart.level);
        if (player.rightPart.id === 'naia') naiaLevel = Math.max(naiaLevel, player.rightPart.level);

        let barieLevel = 0;
        if (player.leftPart.id === 'barie' && player.rightPart.id === 'naia') barieLevel = player.leftPart.level;
        if (player.rightPart.id === 'barie' && player.leftPart.id === 'naia') barieLevel = player.rightPart.level;

        // --- 3. Silphir ì‹œë„ˆì§€ í™•ì¸ [NEW] ---
        let hasSilphir = (player.leftPart.id === 'silphir' || player.rightPart.id === 'silphir');

        // [í•µì‹¬ ë³€ê²½: 5ì´ˆë§ˆë‹¤ ëœë¤ ê°œìˆ˜ ë³€ê²½ ë¡œì§]
        let hasNaia = (player.leftPart.id === 'naia' || player.rightPart.id === 'naia' ||
                       (player.leftPart.id === 'barie' && player.rightPart.id === 'naia') ||
                       (player.rightPart.id === 'barie' && player.leftPart.id === 'naia'));

        if (hasNaia) {
            player.naiaTimer++;
            // 300 í”„ë ˆì„ = 5ì´ˆ (60fps ê¸°ì¤€)
            if (player.naiaTimer >= 300) {
                player.naiaTimer = 0;
                // 1 ~ 3ê°œ ì‚¬ì´ ëœë¤ ì„¤ì •
                player.naiaCurrentCount = Math.floor(Math.random() * 3) + 1;
                if (hasSilphir) player.naiaCurrentCount = Math.max(2 , player.naiaCurrentCount);
                // ì‹œê°ì  í”¼ë“œë°± (íŒŒí‹°í´ ìƒì„±ìœ¼ë¡œ ë³€ê²½ ì•Œë¦¼)
                createParticles(player.x + 25, player.y + 20, 'royalblue');
                console.log("Naia Protocol Updated: " + player.naiaCurrentCount + " Drones");
            }
        } else {
            player.naiaTimer = 0;
        }


        // 1. ëª©í‘œ ë“œë¡  ê°œìˆ˜ ì ìš©
        let naiaTarget = 0;
        let barieTarget = 0;
     
        // Naia ë³¸ì²´: ëœë¤ ì¹´ìš´íŠ¸ ì ìš©
        if (player.leftPart.id === 'naia') {naiaTarget += player.naiaCurrentCount; player.naiaRotation += 0.07;}
        if (player.rightPart.id === 'naia') {naiaTarget += player.naiaCurrentCount; player.naiaRotation -= 0.07;}

        // Barie ë³µì œ: ëœë¤ ì¹´ìš´íŠ¸ ë˜‘ê°™ì´ ë”°ë¼ê° (Naia í”„ë¡œí† ì½œ ê³µìœ )
        if (player.leftPart.id === 'barie' && player.rightPart.id === 'naia') barieTarget += player.naiaCurrentCount;
        if (player.rightPart.id === 'barie' && player.leftPart.id === 'naia') barieTarget += player.naiaCurrentCount;


        // 2. ë“œë¡  ìƒì„±/ì‚­ì œ ë° ë™ì‘ í•¨ìˆ˜ (ê¸°ì¡´ ìœ ì§€)
        const updateDroneGroup = (dronesArray, targetCount, bulletColor, angleModifier, damageLevel, naiadronrotation) => {
            while (dronesArray.length < targetCount) {
                dronesArray.push({ x: player.x, y: player.y, cooldown: Math.random() * 20 });
            }
            while (dronesArray.length > targetCount) {
                dronesArray.pop();
            }

            dronesArray.forEach((drone, index) => {
                let spacingAngle = (Math.PI * 2) / dronesArray.length;
                let currentAngle = naiadronrotation + (spacingAngle * index) + angleModifier;

                drone.x = (player.x + 25) + Math.cos(currentAngle) * radius;
                drone.y = (player.y + 20) + Math.sin(currentAngle) * radius;

                if (drone.cooldown > 0) drone.cooldown--;
                else {
                    // [ë°ë¯¸ì§€ ê³„ì‚°]
                    let finalDmg = 0.5 + (damageLevel - 1) * 0.125; 
                    spawnBullet(drone.x, drone.y, 0, -20, 4, 12, bulletColor, finalDmg, 'rect'); 
                    drone.cooldown = finalCooldown; 
                }
            });
        };

        // Naia ë“œë¡  ê·¸ë£¹ ì‹¤í–‰ (naiaLevel ì „ë‹¬)
        if (naiaTarget > 0) updateDroneGroup(player.naiaDrones, naiaTarget, 'royalblue', 0, naiaLevel, player.naiaRotation);
        
        // Barie ë“œë¡  ê·¸ë£¹ ì‹¤í–‰ (barieLevel ì „ë‹¬)
        if (barieTarget > 0) updateDroneGroup(player.barieNaiaDrones, barieTarget, 'purple', Math.PI / 4, barieLevel, player.naiaRotation*(-1));
    }

    function drawNaiaDrones() {
        // ë‚´ë¶€ ê·¸ë¦¬ê¸° ë„ìš°ë¯¸ í•¨ìˆ˜
        const renderDrone = (drone, index, color, isBarie) => {
            ctx.save();
            ctx.translate(drone.x, drone.y);
            ctx.rotate(player.naiaRotation + (index * 1.5)); 

            ctx.fillStyle = color;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();

            if (!isBarie) {
                // [Naia Original] 1:ì‚¼ê°, 2:ì‚¬ê°, 3:ì›
                if (index === 0) { ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); } 
                else if (index === 1) { ctx.rect(-6, -6, 12, 12); } 
                else { ctx.arc(0, 0, 6, 0, Math.PI * 2); }
            } else {
                // [Barie Copy] 1:ë§ˆë¦„ëª¨, 2:ëª¨ë˜ì‹œê³„(X), 3:ìœ¡ê°í˜•
                if (index === 0) { 
                    // ë§ˆë¦„ëª¨
                    ctx.moveTo(0, -8); ctx.lineTo(6, 0); ctx.lineTo(0, 8); ctx.lineTo(-6, 0); 
                } else if (index === 1) { 
                    // ëª¨ë˜ì‹œê³„ (X ëª¨ì–‘)
                    ctx.moveTo(-6, -6); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.lineTo(6, -6); 
                } else { 
                    // ìœ¡ê°í˜•
                    for (let i = 0; i < 6; i++) {
                        let angle = (Math.PI / 3) * i;
                        let px = Math.cos(angle) * 7;
                        let py = Math.sin(angle) * 7;
                        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                }
            }
            
            ctx.closePath(); // ë„í˜• ë‹«ê¸°
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        };

        // Naia ë“œë¡  ê·¸ë¦¬ê¸° (Blue)
        player.naiaDrones.forEach((d, i) => renderDrone(d, i, 'royalblue', false));
        
        // Barie ë“œë¡  ê·¸ë¦¬ê¸° (Purple)
        player.barieNaiaDrones.forEach((d, i) => renderDrone(d, i, 'purple', true));
    }

    function drawElenaDrones() {
        ctx.fillStyle = 'cyan';
        player.elenaDrones.forEach(d => {
            ctx.beginPath();
            ctx.moveTo(d.x, d.y - 10);
            ctx.lineTo(d.x - 5, d.y + 5);
            ctx.lineTo(d.x + 5, d.y + 5);
            ctx.fill();
        });
    // [ì¶”ê°€] Barie ë“œë¡  (Purple)
        ctx.fillStyle = 'purple';
        player.barieDrones.forEach(d => {
            ctx.beginPath();
            // ëª¨ì–‘ì€ ê°™ì§€ë§Œ ìƒ‰ê¹”ë¡œ êµ¬ë¶„
            ctx.moveTo(d.x, d.y - 10);
            ctx.lineTo(d.x - 5, d.y + 5);
            ctx.lineTo(d.x + 5, d.y + 5);
            ctx.fill();
        });
    }

    function spawnBullet(x, y, vx, vy, w, h, color, dmg, shape='rect') {
        let hasLeets = (player.leftPart.id === 'leets' || player.rightPart.id === 'leets');
        let isBerserk = hasLeets && player.invincible;
        let damageMultiplier = 1.0;
        let damageAdd = 0;
        if (player.leftPart.id === 'leets') damageMultiplier += 0.20 + (player.leftPart.level - 1) * 0.2;
        if (player.rightPart.id === 'leets') damageMultiplier += 0.20 + (player.rightPart.level - 1) * 0.2;
        if (isBerserk) damageAdd = 1;
        let silphirMult = getSilphirMultiplier();

        let finalDamage = dmg * damageMultiplier* silphirMult + damageAdd ;

        // ì´ì•Œ ê°ì²´ë¥¼ ë³€ìˆ˜ì— ë‹´ìŠµë‹ˆë‹¤.
        let newBullet = { x, y, vx, vy, width: w * 2, height: h * 2, color, damage: finalDamage, shape };
        bullets.push(newBullet);
        return newBullet; // [ì¶”ê°€ëœ ë¶€ë¶„] ìƒì„±ëœ ì´ì•Œ ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    }

    function updateBullets() {
        // 1. amelia íŒŒì¸  ì¥ì°© ì—¬ë¶€ ë° ìœ ë„ ì„±ëŠ¥(Strength) ê³„ì‚°
        let homingStrength = 0;
        if (player.leftPart.id === 'amelia' && player.rightPart.id !== 'ner') homingStrength +=  (player.leftPart.level * 0.01);
        if (player.rightPart.id === 'amelia' && player.leftPart.id !== 'ner') homingStrength +=  (player.rightPart.level * 0.01);
        
        // ìœ ë„ ëŒ€ìƒ ëª©ë¡ (ì¼ë°˜ ì  + ë³´ìŠ¤)
        let targets = [...enemies];
        if (boss) targets.push(boss);

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; 
            // [Kidian Sì ê¶¤ì  ë¡œì§ ì¶”ê°€]
            if (b.trajectory === 'sine') {
                b.timer += 0.15; // í”ë“¤ë¦¬ëŠ” ì†ë„ (ì£¼íŒŒìˆ˜)
                // í˜„ì¬ ì§„í–‰ ë°©í–¥ì— ìˆ˜ì§ìœ¼ë¡œ ìœ„ì¹˜ë¥¼ ê°•ì œë¡œ ì´ë™ì‹œí‚µë‹ˆë‹¤.
                // Math.cosë¥¼ ì‚¬ìš©í•˜ì—¬ ë°œì‚¬ ì§í›„ë¶€í„° íœ˜ì–´ì§€ê¸° ì‹œì‘í•˜ê²Œ í•©ë‹ˆë‹¤.
                // 5ëŠ” íœ˜ì–´ì§€ëŠ” í­(ì§„í­)ì…ë‹ˆë‹¤.
                b.x += Math.cos(b.timer) * 5 * b.sidePhase;
            }
            // [amelia íŒ¨ì‹œë¸Œ: ìœ ë„ ë¡œì§] 
            // ameliaê°€ ìˆê³ , í™”ë©´ì— ì ì´ ìˆì„ ë•Œë§Œ ì‘ë™
            if (homingStrength > 0 && targets.length > 0) {
                let closest = null;
                let minDist = Infinity;

                // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                targets.forEach(t => {
                    let dx = (t.x + t.width/2) - b.x;
                    let dy = (t.y + t.height/2) - b.y;
                    let dist = dx*dx + dy*dy; // ê±°ë¦¬ëŠ” ì œê³± ìƒíƒœë¡œ ë¹„êµ (ì—°ì‚° ìµœì í™”)
                    if (dist < minDist) {
                        minDist = dist;
                        closest = t;
                    }
                });

                if (closest) {
                    // ì ì„ í–¥í•œ ê°ë„ ê³„ì‚°
                    let targetX = closest.x + closest.width/2;
                    let targetY = closest.y + closest.height/2;
                    let angle = Math.atan2(targetY - b.y, targetX - b.x);

                    // í˜„ì¬ ì´ì•Œì˜ ì†ë ¥(ìŠ¤í”¼ë“œ) ìœ ì§€
                    let speed = Math.hypot(b.vx, b.vy);
                    
                    // ëª©í‘œ ë°©í–¥ ë²¡í„°
                    let desiredVx = Math.cos(angle) * speed;
                    //let desiredVy = Math.sin(angle) * speed;

                    // í˜„ì¬ ë°©í–¥ì„ ëª©í‘œ ë°©í–¥ìœ¼ë¡œ ì„œì„œíˆ ë³€ê²½ (homingStrength ë§Œí¼)
                    b.vx += (desiredVx - b.vx) * homingStrength;
                    //b.vy += (desiredVy - b.vy) * homingStrength;
                }
            }

            b.x += b.vx; b.y += b.vy; ctx.fillStyle = b.color;
            if (b.shape === 'circle') { ctx.beginPath(); ctx.arc(b.x, b.y, b.width/2, 0, Math.PI*2); ctx.fill(); } else { ctx.fillRect(b.x - b.width/2, b.y, b.width, b.height); }
            if (b.y < -20) bullets.splice(i, 1);
        }
        player.IfritOrbs.forEach(orb => { ctx.fillStyle=orb.color; ctx.fillRect(orb.x-orb.w/2, orb.y-orb.h/2, orb.w, orb.h); });
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            let eb = enemyBullets[i]; eb.x += eb.vx; eb.y += eb.vy; ctx.beginPath(); ctx.arc(eb.x, eb.y, eb.radius || 6, 0, Math.PI*2); ctx.fillStyle = eb.color || 'orange'; ctx.fill();
            if (eb.y > canvas.height + 20 || eb.y < -20 || eb.x < -20 || eb.x > canvas.width + 20) enemyBullets.splice(i, 1);
        }
    }
    
    function fireRing(source, count, speed, bulletColor) {
        let angleStep = (Math.PI * 2) / count;
        for(let i=0; i<count; i++) {
            let angle = angleStep * i;
            enemyBullets.push({ x: source.x + source.width/2, y: source.y + source.height/2, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: 6, color: bulletColor });
        }
    }
    function fireSpiral(source, angleOffset, speed, bulletColor) {
        for(let i=0; i<2; i++) {
            let angle = angleOffset + (Math.PI * i); 
            enemyBullets.push({ x: source.x + source.width/2, y: source.y + source.height/2, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: 6, color: bulletColor });
        }
    }
    function fireAimedFan(source, count, spreadAngle, speed, bulletColor) {
        let px = player.x + player.width/2; let py = player.y + player.height/2;
        let bx = source.x + source.width/2; let by = source.y + source.height/2;
        let baseAngle = Math.atan2(py - by, px - bx);
        let startAngle = baseAngle - (spreadAngle / 2);
        let step = spreadAngle / (count - 1);
        for(let i=0; i<count; i++) {
            let angle = startAngle + step * i;
            enemyBullets.push({ x: bx, y: by, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: 6, color: bulletColor });
        }
    }

    function spawnBoss() {
        enemies.forEach(e => spawnExpOrb(e.x, e.y));
        enemies = [];
        boss = {
            id: 'boss_' + frame,
            x: canvas.width/2 - 50, y: -100, width: 100, height: 100,
            hp: bossMaxHp, maxHp: bossMaxHp, 
            color: '#ff00ff',
            state: 'entering', patternTimer: 0, moveAngle: 0, hitTimer: 0
        };
        uiBossUi.style.display = 'block';
    }

    function updateBoss() {
        if (!boss) {
            if (bossCooldown > 0) { bossCooldown--; } else { if (player.level >= 2) spawnBoss(); }
            return;
        }
        if (boss.state === 'entering') {
            boss.y += 3; if (boss.y >= 50) { boss.y = 50; boss.state = 'phase1'; }
        } else {
            boss.moveAngle += 0.03; boss.x = (canvas.width/2 - 50) + Math.sin(boss.moveAngle) * 100;
            boss.patternTimer++;
            let cycle = boss.patternTimer % 450; 
            if (cycle < 150) { if (cycle % 4 === 0) fireSpiral(boss, boss.patternTimer * 0.15, 6, '#ff99ff'); }
            else if (cycle < 300) { if (cycle % 30 === 0) fireRing(boss, 18, 4.5, '#ff0000'); }
            else { if (cycle % 20 === 0) fireAimedFan(boss, 5, Math.PI/3, 7.5, '#ffff00'); }
        }
        if (boss.hitTimer > 0) { ctx.fillStyle = "white"; boss.hitTimer--; } else { ctx.fillStyle = boss.color; }
        ctx.beginPath(); ctx.moveTo(boss.x + boss.width/2, boss.y); ctx.lineTo(boss.x + boss.width, boss.y + boss.height/3); ctx.lineTo(boss.x + boss.width, boss.y + boss.height); ctx.lineTo(boss.x, boss.y + boss.height); ctx.lineTo(boss.x, boss.y + boss.height/3); ctx.closePath(); ctx.fill();
        uiBossHpBar.style.width = (boss.hp / boss.maxHp * 100) + "%";
        uiBossHpText.innerText = `BOSS HP: ${Math.floor(boss.hp)}/${boss.maxHp}`;
    }

    function useBomb() {
        if (gameState !== "playing" || player.hp <= 0) return;
        if (player.bombs > 0) {
            player.bombs--; flashTimer = 20; 
            enemies.forEach(e => { score += 100; spawnExpOrb(e.x, e.y); createParticles(e.x + e.width/2, e.y + e.height/2, 'white'); });
            enemies = []; enemyBullets = []; 
            if (boss) { boss.hp -= 50; boss.hitTimer = 10; createParticles(boss.x+boss.width/2, boss.y+boss.height/2, '#fff'); if(boss.hp <= 0) killBoss(); }
            updateUI();
        }
    }
    function killBoss() {
        score += 5000; for(let i=0; i<20; i++) spawnExpOrb(boss.x + Math.random()*100, boss.y + Math.random()*100);
        boss = null; uiBossUi.style.display = 'none'; bossCooldown = 1200; bossMaxHp += 50; 
    }

    function checkCollisions() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; let bulletHit = false;
            if (boss) {
                if (rectIntersect(b.x-b.width/2, b.y, b.width, b.height, boss.x, boss.y, boss.width, boss.height)) {
                    boss.hp -= b.damage; boss.hitTimer = 3; createParticles(b.x, b.y, 'purple'); 
                    applyDianaLifesteal(b.damage);
                    bulletHit = true; if (boss.hp <= 0) killBoss();
                }
            }
            if (!bulletHit) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (rectIntersect(b.x-b.width/2, b.y, b.width, b.height, e.x, e.y, e.width, e.height)) {
                        e.hp -= b.damage; e.hitTimer = 3; createParticles(e.x+e.width/2, e.y+e.height/2, 'red'); 
                        applyDianaLifesteal(b.damage);
                        bulletHit = true; if (e.hp <= 0) killEnemy(e, j); break;
                    }
                }
            }
            if(bulletHit) bullets.splice(i, 1);
        }
        for (let i = player.IfritOrbs.length - 1; i >= 0; i--) {
            let k = player.IfritOrbs[i]; let hit = false;
            if (boss && Math.hypot(k.x - (boss.x+boss.width/2), k.y - (boss.y+boss.height/2)) < 60) {
                 boss.hp -= k.damage; boss.hitTimer = 3; createParticles(k.x, k.y, '#333');
                 applyDianaLifesteal(k.damage);
                 hit = true; if (boss.hp <= 0) killBoss();
            }
            if(!hit) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (Math.hypot(k.x - (e.x+e.width/2), k.y - (e.y+e.height/2)) < 30) {
                        e.hp -= k.damage; e.hitTimer = 3; createParticles(k.x, k.y, '#333'); hit = true; 
                        applyDianaLifesteal(k.damage);
                        if (e.hp <= 0) killEnemy(e, j); break;
                    }
                }
            }
            if(hit) player.IfritOrbs.splice(i, 1);
        }
        if (!player.invincible) {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let eb = enemyBullets[i];
                if (Math.hypot(eb.x - (player.x+25), eb.y - (player.y+20)) < (20 + (eb.radius||0))) {
                    takeDamage(10); enemyBullets.splice(i, 1);
                }
            }
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (rectIntersect(player.x, player.y, player.width, player.height, e.x, e.y, e.width, e.height)) {
                    takeDamage(10);
                }
            }
            if (boss && rectIntersect(player.x, player.y, player.width, player.height, boss.x, boss.y, boss.width, boss.height)) {
                takeDamage(20);
            }
        }
    }

    function updatePlayerMove() {
        // [ìˆ˜ì •] ì´ë™ ì†ë„ ë° ë°©í–¥ ê³„ì‚° ë¡œì§ í†µí•©
        let speedMultiple = 1;
        if (player.leftPart.id === 'haley') speedMultiple += (player.leftPart.level * 0.1);
        else if (player.rightPart.id === 'haley') speedMultiple += (player.rightPart.level * 0.1);
        
        if (player.leftPart.id === 'lethe') speedMultiple -= (player.leftPart.level * 0.1);
        else if (player.rightPart.id === 'lethe') speedMultiple -= (player.rightPart.level * 0.1);
        
        let moveSpeed = player.speed * speedMultiple;
        
        let dx = 0;
        let dy = 0;

        // í‚¤ë³´ë“œ ì…ë ¥
        if (keys.ArrowUp) dy -= 1;
        if (keys.ArrowDown) dy += 1;
        if (keys.ArrowLeft) dx -= 1;
        if (keys.ArrowRight) dx += 1;

        // ì¡°ì´ìŠ¤í‹± ì…ë ¥ (í‚¤ë³´ë“œê°€ ì—†ì„ ë•Œë§Œ í˜¹ì€ í•©ì‚°)
        if (joystick.active) {
            dx = joystick.x;
            dy = joystick.y;
        }

        // ì‹¤ì œ ì´ë™ ì ìš©
        player.x += dx * moveSpeed;
        player.y += dy * moveSpeed;

        // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ ì œí•œ
        if (player.x < 0) player.x = 0;
        if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
        if (player.y < 0) player.y = 0;
        if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;

        if (player.invincible) { 
            player.invincibleTimer--; 
            if (player.invincibleTimer <= 0) player.invincible = false; 
        }
    }
    
    function drawPlayer() {
        let w = player.width, h = player.height, x = player.x, y = player.y;
        if (!player.invincible || frame % 10 >= 5) {
            ctx.fillStyle = PARTS_INFO[player.leftPart.id].color; ctx.beginPath(); ctx.moveTo(x + w/2, y); ctx.lineTo(x, y + h); ctx.lineTo(x + w/2, y + h); ctx.fill();
            ctx.fillStyle = PARTS_INFO[player.rightPart.id].color; ctx.beginPath(); ctx.moveTo(x + w/2, y); ctx.lineTo(x + w/2, y + h); ctx.lineTo(x + w, y + h); ctx.fill();
            ctx.fillStyle = "white"; ctx.font = "10px Arial"; ctx.fillText(`L${player.leftPart.level}`, x, y + h + 10); ctx.fillText(`L${player.rightPart.level}`, x + w - 15, y + h + 10);
        }

        // active ìƒíƒœì´ê³  ì‹¤ë“œê°€ 0ë³´ë‹¤ í´ ë•Œë§Œ ê·¸ë¦½ë‹ˆë‹¤.
        if (player.gabiaState === 'active' && player.gabiaShield > 0) {
            ctx.beginPath();
            // ê¸°ì²´ ì¤‘ì‹¬(x+25, y+20)ì„ ê¸°ì¤€ìœ¼ë¡œ ë°˜ì§€ë¦„ 40ì¸ ì›
            ctx.arc(player.x + 25, player.y + 20, 40, 0, Math.PI * 2);
            // ë³´í˜¸ë§‰ ë¹„ìœ¨ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
            let opacity = 0.3 + (player.gabiaShield / player.gabiaMaxShield) * 0.7;
            ctx.strokeStyle = `rgba(139, 69, 19, ${opacity})`; 
            ctx.lineWidth = 3;
            ctx.stroke();
            // ì‚´ì§ ì±„ì›Œì§„ ëŠë‚Œ
            ctx.fillStyle = `rgba(139, 69, 19, 0.1)`;
            ctx.fill();
        }
       
        // [ìˆ˜ì •ë¨] side ì¸ìë¥¼ ë°›ì•„ ìœ„ì¹˜ë¥¼ ë‹¤ë¥´ê²Œ ì„¤ì •
        const drawLaser = (laser, partLevel, side) => {
            if (!laser.active) return;

            let partner = (side === 'left') ? player.rightPart : player.leftPart;
            let isBoosted = (partner.id === 'barie');
            let baseW = 15 + (partLevel - 1) * 5;
            let laserW = isBoosted ? baseW * 1.5 : baseW;
            
            // ê°•í™” ìƒíƒœë©´ ì¤‘ì•™, ì•„ë‹ˆë©´ ì¸¡ë©´
            let ox;
            if (isBoosted) {
                ox = player.x + 25;
            } else {
                ox = (side === 'left') ? player.x + 10 : player.x + 40;
            }
            let oy = player.y ;

            ctx.save();
            ctx.translate(ox, oy); // ê³„ì‚°ëœ ë‚ ê°œ ìœ„ì¹˜ë¡œ ì´ë™
            ctx.rotate(laser.angle + Math.PI / 2); 
            
            // ë ˆì´ì € ë³¸ì²´
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.fillRect(-laserW / 2, -1000, laserW, 1000); 
            
            // ì½”ì–´ (í°ìƒ‰)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(-laserW / 4, -1000, laserW / 2, 1000);
            
            ctx.restore();
        };

        // í˜¸ì¶œ ì‹œ 'left', 'right' ì „ë‹¬
        drawLaser(player.leftLaser, player.leftPart.level, 'left');
        drawLaser(player.rightLaser, player.rightPart.level, 'right');
    }

    function updateEnemies() {
        if(boss) return; 
        let spawnRate = Math.max(20, 60 - (player.level * 3)); 
        if (frame >= nextSpawnFrame) { spawnEnemy(); nextSpawnFrame = frame + spawnRate; }
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (e.state === 'entering') {
                e.y += 3; if (e.y >= e.destY) { e.y = e.destY; e.state = 'idle'; }
            } else if (e.state === 'idle') {
                e.age++; if (e.age > 400) e.state = 'retreating'; 
            } else if (e.state === 'retreating') {
                e.y -= 4.5; if (e.y < -50) { enemies.splice(i, 1); continue; } 
            }
            if (e.state === 'entering' || e.state === 'idle') {
                let attackProb = 0.02 + (player.level * 0.003); 
                if (Math.random() < attackProb) fireAimedBullet(e);
            }
            if (e.hitTimer > 0) { ctx.fillStyle = "white"; e.hitTimer--; } 
            else { ctx.fillStyle = e.color; }
            ctx.fillRect(e.x, e.y, e.width, e.height);
            ctx.fillStyle = "red"; ctx.fillRect(e.x, e.y - 6, e.width * (e.hp / e.maxHp), 4);
        }
    }
    function fireAimedBullet(enemy) {
        let ex = enemy.x + enemy.width / 2; let ey = enemy.y + enemy.height / 2; let px = player.x + player.width / 2; let py = player.y + player.height / 2;
        let angle = Math.atan2(py - ey, px - ex); 
        let speed = 6; 
        enemyBullets.push({ x: ex, y: ey, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: 5 });
    }
    function spawnEnemy() {
        let hp = 5; 
        let destY = 50 + Math.random() * 250; 
        enemies.push({ id: 'e_'+frame+Math.random(), x: Math.random() * (canvas.width - 40), y: -50, destY: destY, width: 40, height: 40, hp: hp, maxHp: hp, color: '#ff4444', state: 'entering', age: 0, hitTimer: 0 });
    }
    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) { return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1; }
    function killEnemy(enemy, index) { enemies.splice(index, 1); score += 100; spawnExpOrb(enemy.x, enemy.y); }
    function spawnExpOrb(x, y) { expOrbs.push({ x: x + 20, y: y + 20, radius: 6, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, val: 5 }); }
    function updateExpOrbs() {
        for (let i = expOrbs.length - 1; i >= 0; i--) {
            let orb = expOrbs[i]; let px = player.x + 25, py = player.y + 20; let dist = Math.hypot(px - orb.x, py - orb.y);
            orb.y += 1.5; 
            if (orb.x < orb.radius) { orb.x = orb.radius; orb.vx *= -1; }
            if (orb.x > canvas.width - orb.radius) { orb.x = canvas.width - orb.radius; orb.vx *= -1; }
            if (dist < 150) { let angle = Math.atan2(py - orb.y, px - orb.x); orb.x += Math.cos(angle) * 12; orb.y += Math.sin(angle) * 12; } 
            else { orb.x += orb.vx; orb.y += orb.vy; orb.vx *= 0.9; orb.vy *= 0.9; }
            ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI*2); ctx.fill();
            if (dist < 30) { gainExp(orb.val); expOrbs.splice(i, 1); continue; }
            if (orb.y > canvas.height + 20) { expOrbs.splice(i, 1); }
        }
    }
    function gainExp(amount) {
        let bonusMult = 1.0; if (player.leftPart.id === 'pira' && player.rightPart.id !== 'kidian') bonusMult += (player.leftPart.level * 0.2); if (player.rightPart.id === 'pira' && player.leftPart.id !== 'kidian') bonusMult += (player.rightPart.level * 0.2);
        let finalExp = amount * bonusMult; player.currentExp += finalExp;
        if (player.currentExp >= player.maxExp) { player.currentExp -= player.maxExp; player.maxExp += 10; player.level++; showUpgradeModal(); }
        updateUI();
    }
    function updatePlayerStats() {
        // 1. ë³€ê²½ ì „ì˜ ìµœëŒ€ ì²´ë ¥ê³¼ í˜„ì¬ ì²´ë ¥ ë¹„ìœ¨ì„ ì €ì¥
        let oldMaxHp = player.maxHp;
        let currentHpRatio = 1.0;
        // ê²Œì„ ì‹œì‘ ì‹œ oldMaxHpê°€ 0ì´ê±°ë‚˜ ì´ˆê¸°í™” ì „ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë°©ì–´ ì½”ë“œ ì‘ì„±
        if (oldMaxHp > 0) {
            currentHpRatio = player.hp / oldMaxHp;
        }
        // [Asana íŒ¨ì‹œë¸Œ: ìµœëŒ€ ì²´ë ¥ ì¬ê³„ì‚°]
        let hpMultiplier = 1.0;
        // ì™¼ìª½ íŒŒì¸  í™•ì¸
        if (player.leftPart.id === 'asana') {
            hpMultiplier += (player.leftPart.level * 0.1);
        }
        if (player.leftPart.id === 'suro') {
            hpMultiplier -= (player.leftPart.level * 0.1);
        }
        // ì˜¤ë¥¸ìª½ íŒŒì¸  í™•ì¸
        if (player.rightPart.id === 'asana') {
            hpMultiplier += (player.rightPart.level * 0.1);
        }
        if (player.rightPart.id === 'suro') {
            hpMultiplier -= (player.rightPart.level * 0.1);
        }
        // ìµœëŒ€ ì²´ë ¥ ê°±ì‹ 
        let newMaxHp = Math.floor(100 * hpMultiplier);
        player.maxHp = newMaxHp;
        // 3. [ë¹„ë¡€ ì ìš©] ì €ì¥í•´ë‘” ë¹„ìœ¨ì„ ìƒˆë¡œìš´ ìµœëŒ€ ì²´ë ¥ì— ê³±í•´ì„œ í˜„ì¬ ì²´ë ¥ ë³´ì •
        // ë‹¨, ì²´ë ¥ì´ 0 ì´í•˜(ì‚¬ë§ ìƒíƒœ)ê°€ ì•„ë‹ˆì—ˆë‹¤ë©´ ìµœì†Œ 1ì€ ë‚¨ê¹€
        player.hp = Math.floor(newMaxHp * currentHpRatio);

        // [ì¶”ê°€ë¨] Gabia Max Shield ê³„ì‚° (ë ˆë²¨ë‹¹ 10)
        let gabiaLevel = 0;
        if (player.leftPart.id === 'gabia') gabiaLevel += player.leftPart.level;
        if (player.rightPart.id === 'gabia') gabiaLevel += player.rightPart.level;
        
        let oldMax = player.gabiaMaxShield;
        player.gabiaMaxShield = gabiaLevel * 20;
        
        // ë ˆë²¨ì—…ìœ¼ë¡œ ìµœëŒ€ì¹˜ê°€ ëŠ˜ì–´ë‚˜ë©´, í˜„ì¬ ì‹¤ë“œëŸ‰ë„ ë¹„ìœ¨ì— ë§ì¶° ëŠ˜ë ¤ì£¼ê±°ë‚˜ ê·¸ëŒ€ë¡œ ë‘ 
        // ì—¬ê¸°ì„œëŠ” ìµœëŒ€ì¹˜ë§Œ ëŠ˜ë¦¬ê³ , íšŒë³µ ë¡œì§ì— ë§¡ê¹€. ë‹¨, ì¥ì°© í•´ì œ ì‹œ 0 ì²˜ë¦¬
        if (player.gabiaMaxShield === 0) {
            player.gabiaShield = 0;
            player.gabiaState = 'active';
        } else if (player.gabiaState === 'active' && player.gabiaShield > player.gabiaMaxShield) {
            player.gabiaShield = player.gabiaMaxShield;
        }
        // ë³€ê²½ëœ ìŠ¤íƒ¯ì„ UIì— ì¦‰ì‹œ ë°˜ì˜
        updateUI();
    }
    function updateUI() {
        // [ìˆ˜ì •ë¨] ì‰´ë“œ ì •ë³´ ì¶”ê°€ í‘œì‹œ
        let shieldInfo = "";
        if (player.gabiaMaxShield > 0) {
            if (player.gabiaState === 'broken') shieldInfo = " [SHIELD REBOOTING...]";
            else shieldInfo = ` [SHIELD: ${Math.floor(player.gabiaShield)}/${player.gabiaMaxShield}]`;
        }

        uiHpBar.style.width = (player.hp / player.maxHp * 100) + "%"; 
        uiHpText.innerText = `HP: ${Math.floor(player.hp)}/${player.maxHp}` + shieldInfo;
        
        // ... ê¸°ì¡´ ì½”ë“œ ...
        uiXpBar.style.width = (player.currentExp / player.maxExp * 100) + "%"; uiXpText.innerText = `LV.${player.level} (${Math.floor(player.currentExp)}/${player.maxExp})`;
        uiScore.innerText = `Score: ${score}`; uiBombText.innerText = `ğŸ’£ BOMB: ${player.bombs} (Key: Z)`;
    }

    function showUpgradeModal() {
        gameState = "paused"; modal.style.display = "flex"; selectUi.style.display = "flex"; replaceUi.style.display = "none";
        upgradeSelectedIndex = 0;
        let keys = Object.keys(PARTS_INFO); keys.sort(() => Math.random() - 0.5); let choices = keys.slice(0, 3);
        currentUpgradeChoices = choices; // ì €ì¥
        cardList.innerHTML = "";
        choices.forEach((key, idx) => {
            let info = PARTS_INFO[key]; 
            let div = document.createElement('div'); div.className = 'card';
            let isOwned = (player.leftPart.id === key || player.rightPart.id === key);
            let currentLevel = 0;
            if(player.leftPart.id === key) currentLevel = player.leftPart.level;
            else if(player.rightPart.id === key) currentLevel = player.rightPart.level;
            let isMax = (isOwned && currentLevel >= 5);
            if(isMax) div.classList.add('disabled');
            div.innerHTML = `${isMax ? '<div class="max-badge">MAX</div>' : ''}<div class="card-icon" style="background:${info.color}; border-radius:50%;"></div><div class="card-name" style="color:${info.color}">${info.name}</div><div class="card-desc">${info.desc}</div><div class="card-level">${isOwned ? 'Lv.' + currentLevel + (isMax ? ' (MAX)' : ' -> ' + (currentLevel+1)) : 'New!'}</div>`;
            div.onclick = () => { if(!isMax) selectUpgradePart(key); }; cardList.appendChild(div);
        });
        updateUpgradeVisuals();
    }
    function selectFixedUpgrade(type) { if (type === 'heal') player.hp = Math.min(player.maxHp, player.hp + 20); else if (type === 'bomb') player.bombs++; updateUI(); finishUpgrade(); }
    function selectUpgradePart(partId) {
        if (player.leftPart.id === partId) { if(player.leftPart.level < 5) { player.leftPart.level++; finishUpgrade(); } } 
        else if (player.rightPart.id === partId) { if(player.rightPart.level < 5) { player.rightPart.level++; finishUpgrade(); } } 
        else { 
            selectedNewPartId = partId; 
            selectUi.style.display = "none"; 
            replaceUi.style.display = "flex"; 
            replaceSelection='left'; 
            updateReplaceVisuals(); 
            document.getElementById('btn-replace-left').innerText = `ì™¼ìª½: ${PARTS_INFO[player.leftPart.id].name} (Lv.${player.leftPart.level}) êµì²´`; 
            document.getElementById('btn-replace-right').innerText = `ì˜¤ë¥¸ìª½: ${PARTS_INFO[player.rightPart.id].name} (Lv.${player.rightPart.level}) êµì²´`; 
        }
    }
    // Button Clicks
    document.getElementById('btn-replace-left').onclick = () => replacePart('left'); 
    document.getElementById('btn-replace-right').onclick = () => replacePart('right');
    document.getElementById('btn-replace-cancel').onclick = () => cancelReplace();

    function replacePart(side) { 
        let oldPart = player[side + 'Part']; let newLevel = Math.max(1, oldPart.level); 
        if (oldPart.id === 'Ifrit') player.IfritOrbs = []; if (oldPart.id === 'elena') player.elenaDrones = []; if (oldPart.id === 'barie') player.barieDrones = []; // [ì¶”ê°€] Barie êµì²´ ì‹œ ë“œë¡  ì‚­ì œ
        
        // êµì²´ ì‹œ ë ˆì´ì € ìƒíƒœ ì´ˆê¸°í™”
        if(oldPart.id === 'lethe') {
             if(side === 'left') player.leftLaser = { active: false, timer: 0 };
             else player.rightLaser = { active: false, timer: 0 };
        }

        player[side + 'Part'] = { id: selectedNewPartId, level: newLevel }; 
    // ì¿¨ë‹¤ìš´(ë”œë ˆì´) ê°•ì œ ì ìš© ---
        if (side === 'left') {
            player.leftCooldown = 0;
        } else {
            player.rightCooldown = 6;
        }

        finishUpgrade(); 
        // [ìˆ˜ì •ë¨] êµì²´ëœ íŒŒì¸ ê°€ Gabiaë¼ë©´ ì‰´ë“œë¥¼ ì¦‰ì‹œ ìµœëŒ€ì¹˜ë¡œ ì¶©ì „
        if (selectedNewPartId === 'gabia') {
            player.gabiaShield = player.gabiaMaxShield;
            player.gabiaState = 'active';
            updateUI(); // UI ì¦‰ì‹œ ê°±ì‹ 
        }
    }
    function cancelReplace() { replaceUi.style.display = "none"; selectUi.style.display = "flex"; }
    function finishUpgrade() { modal.style.display = "none"; gameState = "playing"; updatePlayerStats(); player.invincible = true; player.invincibleTimer = 60; animate(); }
    function createParticles(x, y, color) { for(let i=0; i<8; i++) { particles.push({x, y, vx:(Math.random()-0.5)*7, vy:(Math.random()-0.5)*7, life:10, color}); } }
    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; ctx.fillStyle=p.color; ctx.globalAlpha=p.life/10; ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha=1; if(p.life<=0) particles.splice(i,1); }
    }
    
    //ë°ë¯¸ì§€
    function takeDamage(amount) {
        if (player.invincible) return; 

        // --- Shady ë°ë¯¸ì§€ ë¬´ì‹œ ë¡œì§ (ê¸°ì¡´ ìœ ì§€) ---
        let dodgeChance = 0;
        if (player.leftPart.id === 'shady') dodgeChance = 0.4 + (player.leftPart.level - 1) * 0.1;
        else if (player.rightPart.id === 'shady') dodgeChance = 0.4 + (player.rightPart.level - 1) * 0.1;
        
        if (Math.random() < dodgeChance) {
            createParticles(player.x + 25, player.y + 20, 'cyan');
            console.log("DODGE!");
            // ë¬´ì‹œ ì„±ê³µ ì‹œì—ë„ ì§§ì€ ë¬´ì ì„ ì£¼ì–´ ì—°ì† í”¼ê²© ë°©ì§€ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
            player.invincible = true; player.invincibleTimer = 180;
            return;
        }
        // --- Shady ë¡œì§ ë ---

        // [ì¶”ê°€/ìˆ˜ì •ë¨] Gabia ë³´í˜¸ë§‰ ë¡œì§
        // ë³´í˜¸ë§‰ì´ ì¼œì ¸ìˆê³ (active) ì”ëŸ‰ì´ ìˆì–´ì•¼ í•¨
        if (player.gabiaState === 'active' && player.gabiaShield > 0) {
            player.gabiaShield -= amount;
            player.gabiaHitTimer = 180; // í”¼ê²© ì‹œ 3ì´ˆ(180í”„ë ˆì„) ë™ì•ˆ íšŒë³µ ë©ˆì¶¤
            createParticles(player.x + 25, player.y + 20, '#8B4513'); // ê°ˆìƒ‰ íŒŒí‹°í´

            // ë³´í˜¸ë§‰ì´ ê¹¨ì¡ŒëŠ”ì§€ í™•ì¸
            if (player.gabiaShield <= 0) {
                player.gabiaShield = 0;
                player.gabiaState = 'broken'; // 20ì´ˆ ë¦¬ë¶€íŠ¸ ìƒíƒœë¡œ ì „í™˜
                
                // *** ë³´í˜¸ë§‰ íŒŒê´´ ì‹œì—ë§Œ ë¬´ì  ì‹œê°„ ë¶€ì—¬ (ê¸°ì¡´ ë¬´ì  ë¡œì§ ì ìš©) ***
                player.invincible = true; 
                player.invincibleTimer = 180;
                createParticles(player.x+25, player.y+20, 'white'); // ê¹¨ì§ ì´í™íŠ¸
                console.log("Shield Broken! Rebooting in 20s...");
            } else {
                // ë³´í˜¸ë§‰ì´ ë‚¨ì•„ìˆìœ¼ë©´ ë¬´ì  ì‹œê°„ ì—†ìŒ (ë°”ë¡œ ë‹¤ìŒ ì´ì•Œì— ë§ì„ ìˆ˜ ìˆìŒ)
            }
            updateUI();
            return; // HPëŠ” ê¹ì´ì§€ ì•ŠìŒ
        }

        // ë³´í˜¸ë§‰ì´ ì—†ìœ¼ë©´ ì²´ë ¥ ê°ì†Œ (ê¸°ì¡´ ë¡œì§)
        player.hp -= amount; 
	player.totalHitCount++;
        updateUI();
        if (player.hp > 0) {

            player.invincible = true; player.invincibleTimer = 180;
            createParticles(player.x+25, player.y+20, 'white');
        }
    }

    function updateGabiaShield() {
        // ê°€ë¹„ì•„ íŒŒì¸ ê°€ ì—†ìœ¼ë©´ ë¦¬í„´
        if (player.gabiaMaxShield <= 0) return;

        if (player.gabiaState === 'broken') {
            // [ë¦¬ë¶€íŠ¸ ëª¨ë“œ] 30ì´ˆ(1800í”„ë ˆì„) ë™ì•ˆ 0ì—ì„œ Maxê¹Œì§€ íšŒë³µ
            // í”„ë ˆì„ë‹¹ íšŒë³µëŸ‰ = Max / 1800
            let regenRate = player.gabiaMaxShield / 1800; 
            player.gabiaShield += regenRate;

            // ìµœëŒ€ì¹˜ ë„ë‹¬ ì‹œ í™œì„±í™”
            if (player.gabiaShield >= player.gabiaMaxShield) {
                player.gabiaShield = player.gabiaMaxShield;
                player.gabiaState = 'active';
                createParticles(player.x + 25, player.y + 20, '#8B4513'); // ë³µêµ¬ ì´í™íŠ¸
                updateUI();
            }
        } else {
            // [í™œì„± ëª¨ë“œ]
            // í”¼ê²© ëŒ€ê¸° ì‹œê°„ ì²´í¬
            if (player.gabiaHitTimer > 0) {
                player.gabiaHitTimer--;
            } else {
                // ëŒ€ê¸° ì‹œê°„ ì§€ë‚¬ìœ¼ë©´ 10ì´ˆ(600í”„ë ˆì„) ë™ì•ˆ Maxê¹Œì§€ íšŒë³µ
                if (player.gabiaShield < player.gabiaMaxShield) {
                    let regenRate = player.gabiaMaxShield / 600;
                    player.gabiaShield += regenRate;
                    if (player.gabiaShield > player.gabiaMaxShield) player.gabiaShield = player.gabiaMaxShield;
                    // UI ì—…ë°ì´íŠ¸ëŠ” ë„ˆë¬´ ì¦ìœ¼ë¯€ë¡œ ìƒëµí•˜ê±°ë‚˜ í•„ìš”ì‹œ frame % 60 == 0 ë§ˆë‹¤ í˜¸ì¶œ
                }
            }
        }
        // UIì— ì‹¤ë“œ ìˆ˜ì¹˜ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³´ì—¬ì£¼ê¸° ìœ„í•´ 10í”„ë ˆì„ë§ˆë‹¤ ê°±ì‹ 
        if (frame % 10 === 0) updateUI();
    }
    function applyDianaLifesteal(damage) {
        // ì™¼ìª½ì´ë‚˜ ì˜¤ë¥¸ìª½ì— Dianaê°€ ìˆëŠ”ì§€ í™•ì¸
        if (player.leftPart.id === 'diana' || player.rightPart.id === 'diana') {
            let healAmount = damage * 0.05; // ë°ë¯¸ì§€ì˜ 5%
            if (healAmount > 0) {
                // ìµœëŒ€ ì²´ë ¥ì„ ë„˜ì§€ ì•Šë„ë¡ íšŒë³µ
                player.hp = Math.min(player.maxHp, player.hp + healAmount);
                // (ì„ íƒ) íšŒë³µ ì‹œ UI ì¦‰ì‹œ ê°±ì‹ ì´ í•„ìš”í•˜ë‹¤ë©´ ì•„ë˜ ì£¼ì„ í•´ì œ
                updateUI(); 
            }
        }
    }

    function getSilphirMultiplier() {
        // 1. Silphir ì¥ì°© ì—¬ë¶€ ë° ë ˆë²¨ í™•ì¸
        let silphirLevel = 0;
        if (player.leftPart.id === 'silphir') silphirLevel = Math.max(silphirLevel, player.leftPart.level);
        if (player.rightPart.id === 'silphir') silphirLevel = Math.max(silphirLevel, player.rightPart.level);
    
        // Barie ë³µì œ ê³ ë ¤
        if (player.leftPart.id === 'barie' && player.rightPart.id === 'silphir') silphirLevel = Math.max(silphirLevel, player.leftPart.level);
        if (player.rightPart.id === 'barie' && player.leftPart.id === 'silphir') silphirLevel = Math.max(silphirLevel, player.rightPart.level);

        // ì¥ì°©í•˜ì§€ ì•Šì•˜ìœ¼ë©´ ë°°ìœ¨ 1.0 (ë³€í™” ì—†ìŒ)
        if (silphirLevel === 0) return 1.0;

        // 2. ì§„í–‰ë„ ê³„ì‚° (5ë¶„ = 300ì´ˆ = 18000í”„ë ˆì„)
        let maxFrames = 18000;
        let progress = Math.min(1.0, player.silphirTimer / maxFrames);

        // 3. ë ˆë²¨ë³„ ìµœì†Œ/ìµœëŒ€ ë°°ìœ¨ ê³„ì‚°
        // Lv.1: 1.0 ~ 1.5
        // Lv.5: 1.5 ~ 2.5
        // ì„ í˜• ë³´ê°„ìœ¼ë¡œ ì¤‘ê°„ ë ˆë²¨ ê³„ì‚°
        let startMult = 1.0 + (silphirLevel - 1) * 0.125; // 1.0 ~ 1.5
        let endMult = 1.5 + (silphirLevel - 1) * 0.25;    // 1.5 ~ 2.5

        // í˜„ì¬ ë°°ìœ¨
        return startMult + (endMult - startMult) * progress;
    }
    function updateNerOrbs() {
        // [Amelia ë ˆë²¨ ì²´í¬] (êµ¬ì²´ ìì²´ ìœ ë„ë¥¼ ìœ„í•´)
        let ameliaLevel = 0;
        if (player.leftPart.id === 'amelia') ameliaLevel += player.leftPart.level;
        if (player.rightPart.id === 'amelia') ameliaLevel += player.rightPart.level;
        let homingStrength = ameliaLevel * 0.005; // êµ¬ì²´ëŠ” ë¬´ê±°ìš°ë‹ˆ ìœ ë„ë ¥ì„ ì•½í•˜ê²Œ ì„¤ì •

        for (let i = player.nerOrbs.length - 1; i >= 0; i--) {
            let orb = player.nerOrbs[i];

            // [1] êµ¬ì²´ ìœ ë„ ë¡œì§ (Ameliaê°€ ìˆì„ ë•Œë§Œ)
            if (homingStrength > 0 && !orb.isEnemy) {
                let closest = null;
                let minDist = Infinity;
                
                // ë³´ìŠ¤ ìš°ì„ 
                if (boss) {
                    closest = boss;
                } else if (enemies.length > 0) {
                    enemies.forEach(e => {
                        let d = Math.hypot((e.x+e.width/2)-orb.x, (e.y+e.height/2)-orb.y);
                        if(d < minDist) { minDist = d; closest = e; }
                    });
                }

                if (closest) {
                    let tx = closest.x + closest.width/2;
                    let ty = closest.y + closest.height/2;
                    let angle = Math.atan2(ty - orb.y, tx - orb.x);
                    
                    // í˜„ì¬ ì†ë„ ë²¡í„° ìœ ì§€í•˜ë©° ë°©í–¥ ì„ íšŒ
                    let speed = Math.hypot(orb.vx, orb.vy);
                    let targetVx = Math.cos(angle) * speed;
                    let targetVy = Math.sin(angle) * speed;
                    
                    orb.vx += (targetVx - orb.vx) * homingStrength;
                    orb.vy += (targetVy - orb.vy) * homingStrength;
                }
            }
            
            // 1. ì´ë™ ë° íƒ€ì´ë¨¸
            orb.x += orb.vx;
            orb.y += orb.vy;
            orb.timer++;

            // 2. í­ë°œ ì¡°ê±´ ì²´í¬
            let triggerExplosion = false;

            // (A) ì‹œê°„ì´ ë‹¤ ëì„ ë•Œ
            if (orb.timer >= orb.explodeTime) {
                triggerExplosion = true;
            }

            // (B) ì¶©ëŒ ì²´í¬ (ì•„ì§ ì•ˆ í„°ì¡Œë‹¤ë©´)
            if (!triggerExplosion) {
                if (boss && rectIntersect(orb.x - 10, orb.y - 10, 20, 20, boss.x, boss.y, boss.width, boss.height)) {
                    triggerExplosion = true;
                }
                // ì¼ë°˜ ì  ì¶©ëŒ
                if (!triggerExplosion) {
                    for (let e of enemies) {
                        if (rectIntersect(orb.x - 10, orb.y - 10, 20, 20, e.x, e.y, e.width, e.height)) {
                            triggerExplosion = true;
                            break; // í•˜ë‚˜ë¼ë„ ë‹¿ìœ¼ë©´ í„°ì§
                        }
                    }
                }
            }

            // 3. í­ë°œ ì‹¤í–‰ (ì‹œê°„ ë§Œë£Œ or ì¶©ëŒ)
            if (triggerExplosion) {
                // ì´í™íŠ¸
                createParticles(orb.x, orb.y, orb.isEnemy ? 'red' : 'orange');

                // ì´ì•Œ ê°œìˆ˜ ê³„ì‚°
                let bulletCount = 12 + (orb.level - 1) * 3;
                let angleStep = (Math.PI * 2) / bulletCount;

                for (let j = 0; j < bulletCount; j++) {
                    let angle = angleStep * j;
                    
                    let bx = orb.x;
                    let by = orb.y;
                    let speed = 6;
                    let bvx = Math.cos(angle) * speed;
                    let bvy = Math.sin(angle) * speed;

                    if (orb.isEnemy) {
                        // ì êµ° íƒ„í™˜ (ë°°ì‹ )
                        enemyBullets.push({ x: bx, y: by, vx: bvx, vy: bvy, radius: 4, color: 'red' });
                    } else {
                        // ì•„êµ° íƒ„í™˜ (spawnBullet ì‚¬ìš© -> Silphir, Leets ìë™ ì ìš©)
                        // ì  ë‚´ë¶€ì—ì„œ í„°ì§€ë©´ ì „íƒ„ ëª…ì¤‘í•˜ë¯€ë¡œ ë°ë¯¸ì§€ ë°°ìœ¨ì„ ì¡°ê¸ˆ ì¡°ì •í•´ë„ ë¨ (í˜„ì¬ 0.8)
                        spawnBullet(bx, by, bvx, bvy, 4, 4, 'yellow', 2, 'circle');
                    }
                }

                // êµ¬ì²´ ì‚­ì œ
                player.nerOrbs.splice(i, 1);
                continue; // ê·¸ë¦¬ê¸° ìƒëµí•˜ê³  ë‹¤ìŒ ë£¨í”„ë¡œ
            }

            // 4. í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì‚­ì œ (í­ë°œ ì—†ì´)
            if (orb.y < -50 || orb.y > canvas.height + 50) {
                player.nerOrbs.splice(i, 1);
                continue;
            }

            // 5. ê·¸ë¦¬ê¸° (í­ë°œ ì•ˆ í–ˆì„ ë•Œë§Œ)
            ctx.beginPath();
            ctx.arc(orb.x, orb.y, 10, 0, Math.PI * 2); 
            ctx.fillStyle = orb.isEnemy ? '#8B0000' : '#FF8C00'; 
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function drawGameOver() { ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle = "white"; ctx.textAlign="center"; ctx.font="40px Arial"; ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2); }
    initGame(); animate();
</script>
</body>
</html>